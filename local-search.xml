<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>网易云第三方播放器项目地址</title>
    <link href="/2021/11/04/%E7%BD%91%E6%98%93%E4%BA%91%E7%AC%AC%E4%B8%89%E6%96%B9%E9%A1%B9%E7%9B%AE%E5%9C%B0%E5%9D%80/"/>
    <url>/2021/11/04/%E7%BD%91%E6%98%93%E4%BA%91%E7%AC%AC%E4%B8%89%E6%96%B9%E9%A1%B9%E7%9B%AE%E5%9C%B0%E5%9D%80/</url>
    
    <content type="html"><![CDATA[<h2 id="请复制到浏览器打开"><a href="#请复制到浏览器打开" class="headerlink" title="请复制到浏览器打开"></a>请复制到浏览器打开</h2><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="wushuo-top"><a href="#wushuo-top" class="headerlink" title="wushuo.top"></a>wushuo.top</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JS红宝书（一）Array</title>
    <link href="/2021/11/04/JS%E7%BA%A2%E5%AE%9D%E4%B9%A6%EF%BC%88%E4%B8%80%EF%BC%89Array/"/>
    <url>/2021/11/04/JS%E7%BA%A2%E5%AE%9D%E4%B9%A6%EF%BC%88%E4%B8%80%EF%BC%89Array/</url>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">push()<br><br>接受任意数量的参数，把他们逐个添加到数组末尾，并返回修改后数组的长度。<br><br>pop()<br><br>从数组末尾移除最后一项，减少数组的length值，然后返回移除的项。<br></code></pre></td></tr></table></figure><h3 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">shift()<br><br>移除数组中的第一项并返回该项，同时将数组长度减一。<br><br>unshift()<br><br>在数组的前端添加任意一个项并返回数组的长度。<br></code></pre></td></tr></table></figure><h3 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">reverse()<br><br>反转数组排序<br><br>sort()<br><br>默认情况下，sort()方法按照升序排序数组项（最小的位于最前面，最大的值排在最后面）。为了实现排序，sort()方法会调用每个数组项的toString()转型方法，然后比较得到的字符串。<br></code></pre></td></tr></table></figure><h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">concat()<br><br>这个方法会先创建当前数组的一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新创建的数组。在没有给concat()方法传递参数的情况下，他只是复制当前数组并返回副本。如果传递给concat()方法的是一个或多个数组，则该放放会将这些数组中的每一项都添加到结果数组中。<br><br>slice()<br><br>slice() 方法可以接受一个或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下，该参数是起始位置，返回从起始位置到当前数组末尾的所有项。slice()方法不会影响原数组。<br><br>splice()<br><br>删除：可以删除数组的任意项，只需要指定两个参数：删除的位置和要删除的项数。例如，splice(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>)会删除数组中的前两项。<br>插入：可以向指定位置插入任意数量的项，只需要提供三个参数：起始位置、<span class="hljs-number">0</span>（要删除的项数）和要插入的项（可以为多个）。例如：splice(<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,”dog”,”cat”)<br>替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项。插入的项数不必与删除的项数相同。例如：splice(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,”dog”,”cat”)<br></code></pre></td></tr></table></figure><h3 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">every()：对数组中的每一项运行给定函数，如果该函数每一项都返回<span class="hljs-literal">true</span>，则返回<span class="hljs-literal">true</span>。<br><br>filter()：对数组中的每一项运行给定函数，返回该函数会返回<span class="hljs-literal">true</span>的项组成的数组。<br><br>forEach()：对数组中的每一项运行给定函数，该函数没有返回值。<br><br>map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。<br><br>some()：对数组中的每一项运行给定函数，如果对该函数任意一项返回<span class="hljs-literal">true</span>，则返回<span class="hljs-literal">true</span>。<br></code></pre></td></tr></table></figure><h3 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">reduce()：从数组的第一项开始，逐个遍历到最后。<br><br>reduceRight()：从数组的最后一项开始，向前遍历到第一项。<br></code></pre></td></tr></table></figure><p>传给reduce()和reduceRight()的函数接收4个参数：前一个值，当前值，项的索引和数组对象。</p>]]></content>
    
    
    <categories>
      
      <category>Js</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>时间调度笔记</title>
    <link href="/2021/09/30/%E6%97%B6%E9%97%B4%E8%B0%83%E5%BA%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/09/30/%E6%97%B6%E9%97%B4%E8%B0%83%E5%BA%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>10m*12个</p><h4 id="00-乱七八糟"><a href="#00-乱七八糟" class="headerlink" title="00.乱七八糟"></a><strong>00.乱七八糟</strong></h4><p>答题思路：概念，优缺点，用法，使用场景</p><p>构造函数：用来实例化对象</p><p>Vue-admin-template 适合二次开发</p><p>不需要路由，可复用的组件 放 components</p><p><strong>需要路由</strong>的组件，放到views</p><p>自定义ESlint规则 放到 .eslintrc.js 文件的 rules对象下</p><p>-S 开发和生产环境都需要</p><p>-D 只在开发阶段写代码时会用到</p><p>axios.create 创建实例</p><p>响应拦截器：主要处理 返回的**<code>数据异常</code>** 和**<code>数据结构</code>**问题    来自：基础环境搭建</p><p>refresh token 续命陶肯</p><p>在CSS中用@需要加小虫</p><p>vue项目中的style加上scoped后是局部样式</p><p>if 存在  else 不存在</p><p>router-view 二级路由挂载点</p><p>Mutation 的自定义方法 第一个形参是state，第二个形参是自定义的</p><p>AXios是一个基于promise的HTTP库，简单来讲就是可以发送get,post请求，可以用在浏览器和nodejs中<br>可以进行的操作有，发送请求，请求拦截器，相应拦截器，取消请求等。<br>底层使用的还是XMLHTTP</p><p>export default 下的 components 是用来注册子组件的</p><p>Vue框架更新DOM的过程是异步的</p><p>Vant有赞组件库可以主题定制-拉到最下边：<a href="https://vant-contrib.gitee.io/vant/#/zh-CN/theme">https://vant-contrib.gitee.io/vant/#/zh-CN/theme</a></p><p>vue中axios的封装以及简单使用：<a href="https://www.cnblogs.com/shenjianping/p/11448247.html">https://www.cnblogs.com/shenjianping/p/11448247.html</a></p><p>Lazyload 懒加载 vant有赞自带 懒加载</p><p>组件导入：按需导入有引号 全局没有</p><p>router-link 本质是a标签</p><p>$route 传参       $router 调方法</p><p>前端将对象数据处理成JSON字符串（JSON.stringify）</p><p>阿贾克斯，异步的</p><p>环境变量，在.env.development中配置</p><p>捕获async await 异常，需要用到 <strong>try  catch</strong>  语句</p><p>当账号密码输入正确，系统log提示错误的时候，检查参数是否写对，传对</p><p>dispatch是异步的，需要加await 同步化</p><p>vmodu快速打出vuex</p><p><strong>eslint加规则</strong>，打开报错链接，复制标题，在eslint配置文件中添加，”vue/html-indent”: “off”,  “规则名”: “off”,</p><p><a href="https://www.cnblogs.com/yuxinyu/p/14673447.html">router-view的key属性的作用</a></p><p>因为Vue会有组件之间的复用，如果两个路由都使用到了某一个组件，这个组件是不会再去执行created和mounted这些钩子函数的，加了key就是可以当成两个不同的界面去使用。</p><p>ctrl+shift+K 删除整行</p><p>handleClose 是控制弹层叉号的</p><p>有Token报401错误 看request请求头</p><p>数据盒子纵向纵列排序：display: flex; flex-flow: column; flex-wrap: wrap;</p><p>退出登录的提示弹层在messagebox做</p><p>对象合并，展开运算符+解构放进去</p><p>Git bash图形化操作  mkdir 批量创建文件夹   touch 批量创建文件</p><p>弹层组件放在最后一个div根元素之前</p><p>枚举类型：可遍历的数据类型（数组，对象），里边一个一个的数组就是<strong>数据字典</strong></p><p>COS云服务器对象存储：设置cors规则跨域，安全管理-跨域访问，来源设置为*，星的意思是指任何来源都可以访问</p><p><img src="https://wushuo1031.oss-cn-beijing.aliyuncs.com/img/image-20211024200009147.png" alt="image-20211024200009147"></p><p>敏感操作，提示框 =》 this.$confirm(‘确认删除吗’, ‘提示’)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">this</span>.$confirm(<span class="hljs-string">&#x27;确认删除吗&#x27;</span>, <span class="hljs-string">&#x27;提示&#x27;</span>).then(<span class="hljs-function">() =&gt;</span> &#123;<br><br>&#125;).catch(<span class="hljs-built_in">console</span>.log)<br></code></pre></td></tr></table></figure><p>清空表单（只能清除添加了校验的数据） =》  this.$refs.表单名.resetFields()</p><p>三元表达式动态显示标题 =》      :title=”formData.id ? ‘编辑权限’ : ‘新增权限’”</p><p>拆分组件，模块化组件，不能加.sync  因为违反了单向数据流  如果dialog直接放进去不封装可以加 :visible.sync</p><p>mounted发请求可能会闪一下，科瑞踢德不会，因为mounted是先加载完DOM，在请求数据</p><p>maxin可以全局注册一个方法，写完需要在main.js引入注册  1.import ckp from ‘@/utils/mixin’      2. Vue.mixin(ckp)</p><p>Echas图表，的CSS必须要给宽高</p><p>Vue往<strong>原型链上挂东西</strong>，人力练习项目utils文件夹-echas.js   Vue.phototype.echarts = echarts   注册完需要在min.js导入</p><p><img src="https://wushuo1031.oss-cn-beijing.aliyuncs.com/img/image-20211029001346334.png" alt="image-20211029001346334"></p><p>mixin和往<strong>原型链上挂东西</strong> 都可以定义全局公共方法JS</p><p>&amp;&amp; 需要两边都是true 才返回 true  有一个是false结果也是false             秘籍：都为真 才是真</p><p>|| 两边 只要 有一个是正确的 则返回 true   两个都为假 结果才是false     秘籍：都为假 才是假</p><p>给input框 添加 一进入页面就获取焦点：第一行代码： const ipt = document.querySelector(‘input’)               第二行代码：  ipt.focus()</p><p>this.data定义.length === 0  代表用户输入的空内容  头条 05-10</p><p><strong>三元表达式食用方法：</strong></p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ada"><br>条件表达式 ? 表达式<span class="hljs-number">1</span> : 表达式2<br><br>执行思路：如果条件表达式结果为<span class="hljs-literal">true</span>，则返回表达式<span class="hljs-number">1</span>的值，如果条件表达式结果为假，则返回表达式<span class="hljs-number">2</span>的值 <br><br></code></pre></td></tr></table></figure><h4 id="1-说说你对盒子模型的理解"><a href="#1-说说你对盒子模型的理解" class="headerlink" title="1.说说你对盒子模型的理解"></a><strong>1.说说你对盒子模型的理解</strong></h4><p>盒子模型分为两种，一种是标准盒子模型，一种是怪异盒子模型。</p><p>标准盒模型下盒子的大小 = content + border + padding + margin<br>（内容+边框+pending+马竞）</p><p>怪异盒模型中的 宽 指的是内容、边框、内边距总的宽度；高 指的是内容、边框、内边距总的高度</p><p>怪异盒模型下盒子的大小=width（content + border + padding） + margin</p><h4 id="2-JS数组常用方法"><a href="#2-JS数组常用方法" class="headerlink" title="2.JS数组常用方法"></a><strong>2.JS数组常用方法</strong></h4><p><strong>Push，做添加新增功能的，向数组末尾一个或多个元素，并返回数组新的长度；</strong></p><p><strong>Pop，删除数组最后一个元素，被删除的元素作为返回值返回；</strong></p><p><strong>Unshift，向数组开头添加一个或多个元素，并返回数组新的长度；</strong></p><p><strong>Shift，删除数组第一个元素，被删除的元素作为返回值返回；</strong></p><p><strong>splice，做删除功能的，删除数组中一个或连续的元素，而且可以再删除位置添加新的元素，删除的元素作为返回值返回；</strong></p><p><strong>concat，合并多个数组，并返回一个新数组；</strong></p><p><strong>indexOf，返回置顶元素在数组中第一次出现的位置；</strong></p><p><strong>forEach，接受一个函数作为参数，遍历数组时，所有数组成员依次执行该函数，中途不可停止。</strong></p><p><strong>filter，数组过滤方法</strong></p><p>数组基本操作可以归纳为 增删改查 。</p><p>增  前三个会影响原数组，第四个不会。</p><p>push()方法接收任意数量的参数，并将它们添加到数组末尾，返回数组的最新长度</p><p>unshift()在数组开头添加任意多个值，然后返回新的数组长度</p><p>splice() 传入三个参数，分别是开始位置、0（要删除的元素数量）、插入的元素，返回空数组</p><p>concat() 首先会创建一个当前数组的副本，然后再把它的参数添加到副本末尾，最后返回这个新构建的数组，不会影响原始数组</p><p>删 下面三种都会影响原数组，最后一项不影响原数组</p><p>pop() 方法用于删除数组的最后一项，同时减少数组的 length 值，返回被删除的项</p><p>shift()方法用于删除数组的第一项，同时减少数组的 length 值，返回被删除的项</p><p><strong>splice</strong>() 传入两个参数，分别是开始位置，删除元素的数量，返回包含删除元素的数组  <strong>常被用作删除功能</strong></p><p>slice()  用于创建一个包含原有数组中一个或多个元素的新数组，不会影响原始数组</p><p>改 splice() 传入三个参数，分别是开始位置，要删除元素的数量，要插入的任意多个元素，返回删除元素的数组，对原数组产生影响</p><p>查 </p><p>indexOf() 返回要查找的元素在数组中的位置，如果没找到则返回-1</p><p><strong>includes()</strong> 查找数据中存 不存在 这个值，找到返回true，否则false</p><p>find() 返回第一个匹配的元素</p><ul><li><p><strong>创建一个新数组，新数组是b项的值，而且需要去重。</strong></p></li><li><p>```js</p><pre><code>  let res = [    &#123; a: &#39;1&#39;, b: &#39;2&#39;, c: &#39;3&#39; &#125;,    &#123; a: &#39;21&#39;, b: &#39;2res&#39;, c: &#39;j&#39; &#125;,    &#123; a: &#39;31&#39;, b: &#39;2res&#39;, c: &#39;3j&#39; &#125;,    &#123; a: &#39;15&#39;, b: &#39;2r&#39;, c: &#39;3re&#39; &#125;,    &#123; a: &#39;61&#39;, b: &#39;2r&#39;, c: &#39;3ers&#39; &#125;,  ]    console.log(new Set(res.map((w) =&gt; w.b)))      // 结果是 Set(3) &#123;&quot;2&quot;, &quot;2res&quot;, &quot;2r&quot;&#125;</code></pre><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>  <br><br>**split()方法 把字符转转换为数组**<br><br>reverse() 方法 翻转世界 颠倒数组顺序<br><br>#### **<span class="hljs-number">3.</span>JS字符串的常用方法有哪些？**<br><br>**includes，查找字符串是否包含 <span class="hljs-string">&quot;Runoob&quot;</span>**<br><br>```js<br><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;Hello world, welcome to the Runoob。&quot;</span>;<br><span class="hljs-keyword">let</span> res = str.includes(<span class="hljs-string">&quot;world&quot;</span>);<br><br><span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li></ul><p>我们也可将字符串常用的操作方法归纳为增、删、改、查，需要知道的是字符串的特点是一旦创建了，就不可变。</p><p><strong>增</strong></p><p>concat</p><p>用于将一个或多个字符串拼接成一个新字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> niu = <span class="hljs-string">&quot;hello &quot;</span>;<br><span class="hljs-keyword">let</span> bi = niu.concat(<span class="hljs-string">&quot;world&quot;</span>);<br><span class="hljs-built_in">console</span>.log(niu); <span class="hljs-comment">// &quot;hello world&quot;</span><br><span class="hljs-built_in">console</span>.log(bi); <span class="hljs-comment">// &quot;hello&quot;</span><br></code></pre></td></tr></table></figure><p><strong>删</strong></p><p>这里的删的意思并不是说删除原字符串的内容，而是创建字符串的一个副本，再进行操作</p><p>常见的有：</p><ul><li>slice()</li><li>substr()</li><li>substring()</li></ul><p>这三个方法都返回调用它们的字符串的一个子字符串，而且都接收一或两个参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> stringValue = <span class="hljs-string">&quot;hello world&quot;</span>;<br><span class="hljs-built_in">console</span>.log(stringValue.slice(<span class="hljs-number">3</span>)); <span class="hljs-comment">// &quot;lo world&quot;</span><br><span class="hljs-built_in">console</span>.log(stringValue.substring(<span class="hljs-number">3</span>)); <span class="hljs-comment">// &quot;lo world&quot;</span><br><span class="hljs-built_in">console</span>.log(stringValue.substr(<span class="hljs-number">3</span>)); <span class="hljs-comment">// &quot;lo world&quot;</span><br><span class="hljs-built_in">console</span>.log(stringValue.slice(<span class="hljs-number">3</span>, <span class="hljs-number">7</span>)); <span class="hljs-comment">// &quot;lo w&quot;</span><br><span class="hljs-built_in">console</span>.log(stringValue.substring(<span class="hljs-number">3</span>,<span class="hljs-number">7</span>)); <span class="hljs-comment">// &quot;lo w&quot;</span><br><span class="hljs-built_in">console</span>.log(stringValue.substr(<span class="hljs-number">3</span>, <span class="hljs-number">7</span>)); <span class="hljs-comment">// &quot;lo worl&quot;</span><br></code></pre></td></tr></table></figure><p><strong>改</strong></p><p>这里改的意思也不是改变原字符串，而是创建字符串的一个副本，再进行操作</p><p>常见的有：</p><ul><li>trim()、trimLeft()、trimRight()</li><li>repeat()</li><li>padStart()、padEnd()</li><li>toLowerCase()、 toUpperCase()</li></ul><p><strong>trim()、trimLeft()、trimRight()</strong></p><p>删除前、后或前后所有空格符，再返回新的字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> niu = <span class="hljs-string">&quot; hello world &quot;</span>;<br><span class="hljs-keyword">let</span> bi = niu.trim();<br><span class="hljs-built_in">console</span>.log(niu); <span class="hljs-comment">// &quot; hello world &quot;</span><br><span class="hljs-built_in">console</span>.log(bi); <span class="hljs-comment">// &quot;hello world&quot;</span><br></code></pre></td></tr></table></figure><p><strong>repeat()</strong></p><p>接收一个整数参数，表示要将字符串复制多少次，然后返回拼接所有副本后的结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> stringValue = <span class="hljs-string">&quot;na &quot;</span>;<br><span class="hljs-keyword">let</span> copyResult = stringValue.repeat(<span class="hljs-number">2</span>) <span class="hljs-comment">// na na </span><br></code></pre></td></tr></table></figure><p><strong>padEnd()</strong></p><p>复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件，写什么填充什么</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> stringValue = <span class="hljs-string">&quot;foo&quot;</span>;<br><span class="hljs-built_in">console</span>.log(stringValue.padStart(<span class="hljs-number">6</span>)); <span class="hljs-comment">// &quot; foo&quot;</span><br><span class="hljs-built_in">console</span>.log(stringValue.padStart(<span class="hljs-number">9</span>, <span class="hljs-string">&quot;.&quot;</span>)); <span class="hljs-comment">// &quot;......foo&quot;</span><br></code></pre></td></tr></table></figure><p><strong>toLowerCase()、 toUpperCase()</strong></p><p>大小写转化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> stringValue = <span class="hljs-string">&quot;hello world&quot;</span>;<br><span class="hljs-built_in">console</span>.log(stringValue.toUpperCase()); <span class="hljs-comment">// &quot;HELLO WORLD&quot;</span><br><span class="hljs-built_in">console</span>.log(stringValue.toLowerCase()); <span class="hljs-comment">// &quot;hello world&quot;</span><br></code></pre></td></tr></table></figure><p><strong>查</strong></p><p>除了通过索引的方式获取字符串的值，还可通过：</p><ul><li>chatAt()</li><li>indexOf()</li><li>startWith()</li><li>includes()</li></ul><p><strong>charAt()</strong></p><p>返回给定索引位置的字符，由传给方法的整数参数指定</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> message = <span class="hljs-string">&quot;abcde&quot;</span>;<br><span class="hljs-built_in">console</span>.log(message.charAt(<span class="hljs-number">2</span>)); <span class="hljs-comment">// &quot;c&quot;</span><br></code></pre></td></tr></table></figure><p><strong>indexOf()</strong></p><p>从字符串开头去搜索传入的字符串，并返回位置（如果没找到，则返回 -1 ）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> stringValue = <span class="hljs-string">&quot;hello world&quot;</span>;<br><span class="hljs-built_in">console</span>.log(stringValue.indexOf(<span class="hljs-string">&quot;o&quot;</span>)); <span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure><p><strong>startWith()、includes()</strong></p><p>从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> message = <span class="hljs-string">&quot;foobarbaz&quot;</span>;<br><span class="hljs-built_in">console</span>.log(message.startsWith(<span class="hljs-string">&quot;foo&quot;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(message.startsWith(<span class="hljs-string">&quot;bar&quot;</span>)); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(message.includes(<span class="hljs-string">&quot;bar&quot;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(message.includes(<span class="hljs-string">&quot;qux&quot;</span>)); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h4 id="4-和-区别，分别在什么情况使用？"><a href="#4-和-区别，分别在什么情况使用？" class="headerlink" title="4.== 和 ===区别，分别在什么情况使用？"></a>4.<strong>== 和 ===区别，分别在什么情况使用？</strong></h4><p>相等操作符（==），全等操作符（===） </p><p>JS中存在隐式转换，等于操作符（==）在比较中会先进行类型转换，再确定操作数是否相等。</p><ul><li>两个都为简单类型，字符串和布尔值都会转换成数值，再比较</li><li>简单类型与引用类型比较，对象转化成其原始类型的值，再比较</li><li>两个都为引用类型，则比较它们是否指向同一个对象</li><li>null 和 undefined 相等</li><li>存在 NaN 则返回 false</li></ul><p>全等操作符由 3 个等于号（ === ）表示，只有两个操作数在不转换的前提下相等才返回 <code>true</code>。即类型相同，值也需相同</p><h4 id="5-深拷贝浅拷贝的区别？"><a href="#5-深拷贝浅拷贝的区别？" class="headerlink" title="5.深拷贝浅拷贝的区别？"></a><strong>5.深拷贝浅拷贝的区别？</strong></h4><p>JS中存在两大数据类型。</p><p>基本类型数据保存在在栈内存中</p><p>引用类型数据保存在堆内存中，引用数据类型的变量是一个指向堆内存中实际对象的引用，存在栈中</p><p>就是假设B复制了我，当修改我时，看B是否会发生变化，如果B也跟着变了，说明这是浅拷贝，拿人手短，如果B没变，那就是深拷贝，自食其力。</p><p>无论是使用扩展运算符(…)还是解构赋值，对于引用类型都是浅拷贝。所以在使用splice()、concat()、…对数组拷贝时，只有当数组内部属性值不是引用类型是，才能实现深拷贝。</p><p>深拷贝代码：JSON.parse(JSON.stringify(数据名))</p><h4 id="6-TCP为什么需要三次握手和四次挥手？"><a href="#6-TCP为什么需要三次握手和四次挥手？" class="headerlink" title="6.TCP为什么需要三次握手和四次挥手？"></a><strong>6.TCP为什么需要三次握手和四次挥手？</strong></h4><p><strong>三次握手</strong>是指建立一个TCP连接时，需要客户端和服务器总共发送3个包</p><p>主要作用就是为了确认双方的接收能力和发送能力是否正常</p><p><strong>四次挥手原因</strong></p><p>服务端在收到客户端断开连接<code>Fin</code>报文后，并不会立即关闭连接，而是先发送一个<code>ACK</code>包先告诉客户端收到关闭连接的请求，只有当服务器的所有报文发送完毕之后，才发送<code>FIN</code>报文断开连接，因此需要四次挥手</p><h4 id="7-cookie，localstorage，sessionstorage-的区别"><a href="#7-cookie，localstorage，sessionstorage-的区别" class="headerlink" title="7.cookie，localstorage，sessionstorage 的区别"></a><strong>7.cookie，localstorage，sessionstorage 的区别</strong></h4><p>1、生命周期：</p><ul><li>Cookie：可设置失效时间，否则默认为关闭浏览器后失效</li><li>Localstorage:除非被手动清除，否则永久保存</li><li>Sessionstorage：仅在当前网页会话下有效，关闭页面或浏览器后就会被清除</li></ul><p>2、存放数据：</p><ul><li>Cookie：4k 左右</li><li>Localstorage 和sessionstorage：可以保存5M 的信息</li></ul><p>3、应用场景：</p><ul><li>从安全性来说，因为每次http请求都会携带cookie 信息，这样子浪费了带宽，所以cookie应该尽可能的少用。</li><li>此外cookie 还需要指定作用域，不可以跨域调用，限制很多，但是用户识别用户登陆来说，cookie 还是比storage 好用。</li><li>其他情况下可以用storage，localstorage可以用来在页面传递参数，sessionstorage 可以用来保存一些临时的数据，防止用户刷新页面后丢失了一些参数。</li></ul><h4 id="8-对HTML语义化标签的理解"><a href="#8-对HTML语义化标签的理解" class="headerlink" title="8.对HTML语义化标签的理解"></a><strong>8.对HTML语义化标签的理解</strong></h4><p> HTML5 语义化标签是指正确的标签包含了正确的内容，结构良好，便于阅读，比如nav 表示导航条，类似的还有article、header、footer 等等标签，使用语义化标签可以使搜索引擎的爬虫效果更好，易于seo优化。</p><h4 id="9-H5-C3新属性"><a href="#9-H5-C3新属性" class="headerlink" title="9.H5.C3新属性"></a><strong>9.H5.C3新属性</strong></h4><ul><li>Box-shadow 盒子阴影</li><li>Box-radius 圆角边框</li><li>css3选择器 last-child、nth-child</li><li>渐变</li><li>弹性盒flex</li><li>过渡、动画、变形</li></ul><p>8 个语义元素header头部 section内容段落 footer脚部区域 aside nav导航部分 main文档的主体内容 article figure</p><p>内容元素mark 高亮progress 进度</p><p>新的表单控件calander date time email url search</p><p>新的input 类型color date datetime datetime-local email</p><p>移除过时标签big font frame frameset</p><p>canvas 绘图，支持内联SVG。支持MathML</p><p>多媒体audio video</p><p>本地离线存储，把需要离线存储在本地的文件列在一个manifest 配置文件</p><p>web 存储。localStorage、SessionStorage</p><h4 id="10-ES6-的新增方法"><a href="#10-ES6-的新增方法" class="headerlink" title="10.ES6 的新增方法"></a><strong>10.ES6 的新增方法</strong></h4><ul><li>新增声明命令 let 和 const</li><li>模板字符串</li><li>箭头函数</li><li>ES6 允许在对象之中，直接写变量。</li><li>promise <strong>是同步的</strong>  .then是<strong>异步的</strong></li></ul><h4 id="11-生命周期函数"><a href="#11-生命周期函数" class="headerlink" title="11.生命周期函数"></a><strong>11.生命周期函数</strong></h4><p>beforeCreate(创建前）created(创建后）beforeMounted(挂载前） mounted(挂载后）</p><p>beforeUpdate（更新前） updated(更新后）beforeDestroy（销毁前） destroyed(销毁后)</p><p>created和mounted区别？  // created拿不到DOM 是 undifand  mounted 可以成功拿到DOM</p><ul><li><p>beforeCreate 获取不到data数据 ，log返回的是undifand</p></li><li><p>如果要调用methods中的方法，或者操作data中的数据，最早，只能在**created()**中操作(发请求) </p></li><li><p>如果要通过某些插件操作页面上的DOM节点了，最早要在<strong>mounted</strong> 中才可以<strong>操作DOM</strong></p></li><li><p>只要执行完了<strong>mounted</strong>，就表示整个Vue实例已经初始化完毕了，此时组件已经脱离了创建阶段，进入到了运行阶段 </p></li><li><p>每次数据发生变化，都会执行<strong>beforeUpdate</strong>和<strong>updated</strong></p></li><li><p>得出结论：当执行<strong>beforeUpdate</strong>的时候，页面中的显示的数据，还是旧的，此时data数据是最新的，页面尚未和最新的数据保持同步 </p></li><li><p><strong>updated</strong>事件执行的时候，页面和data数据已经保持同步了。都是最新的</p></li><li><p><strong>我们可以发现父子组件在加载的时候，执行的先后顺序为父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted。</strong></p></li><li><p>mounted和created区别</p></li><li><p>created:在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。 </p></li><li><p>mounted:在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。</p></li></ul><p><a href="https://blog.csdn.net/qq_42698576/article/details/109109555">https://blog.csdn.net/qq_42698576/article/details/109109555</a></p><h4 id="12-Ajax-的原理"><a href="#12-Ajax-的原理" class="headerlink" title="12.Ajax 的原理"></a><strong>12.Ajax 的原理</strong></h4><p>通过 XmlHTTPRequest 对象来向服务器发异步请求，从服务器获得数据，然后用 javascript 来 操作 DOM 而更新页面。</p><h4 id="13-V-for和V-if不能连用？"><a href="#13-V-for和V-if不能连用？" class="headerlink" title="13.V-for和V-if不能连用？"></a><strong>13.V-for和V-if不能连用？</strong></h4><ul><li>涉及到优先级问题，V-for会比V-if有优先执行</li><li>如果每一次都需要遍历整个数组，将会影响速度</li></ul><h4 id="14-MVVM是什么？"><a href="#14-MVVM是什么？" class="headerlink" title="14.MVVM是什么？"></a><strong>14.MVVM是什么？</strong></h4><p>是一种架构设计模式，也就是数据驱动视图，其中M代表数据模型，V代表视图，VM代表的就是视图模型。</p><ul><li>M：   model数据模型            (data里定义)    </li><li>V：    view视图                   （template里定义html页面结构）</li><li>VM： ViewModel视图模型   (vue组件实例this)</li></ul><h4 id="15-同步和异步的区别"><a href="#15-同步和异步的区别" class="headerlink" title="15.同步和异步的区别"></a><strong>15.同步和异步的区别</strong></h4><p>先执行<strong>同步</strong>，后执行异步</p><p>同步的思想是：所有的操作都做完，才返回给用户。</p><p>异步：所有的操作同步执行。</p><h4 id="16-宏任务和微任务"><a href="#16-宏任务和微任务" class="headerlink" title="16.宏任务和微任务"></a><strong>16.宏任务和微任务</strong></h4><p>先执行<strong>同步</strong>，后执行异步</p><p>结论：微任务执行时机比宏任务早</p><p>宏任务：定时器，seetInterval,DOM事件，阿贾克斯请求。</p><p>微任务：Promise，async/await</p><p>微任务》DOM渲染</p><p><strong>任务队列</strong>里放的都是异步任务</p><h4 id="17-vue中data为什么必须是函数"><a href="#17-vue中data为什么必须是函数" class="headerlink" title="17.vue中data为什么必须是函数"></a><strong>17.vue中data为什么必须是函数</strong></h4><p>vue中data必须是函数是为了保证组件的独立性和可复用性，data是一个函数，组件实例化的时候这个函数将会被调用，返回一个对象</p><h4 id="18-Vue常用指令"><a href="#18-Vue常用指令" class="headerlink" title="18.Vue常用指令"></a><strong>18.Vue常用指令</strong></h4><ul><li>v-bind 简写: 用于动态绑定数据例如 :src 可以绑定网址</li><li>v-on 绑定点击事件的玩意</li><li>v-model 主要在表单开发使用</li><li>v-text 会显示标签内容  官方叫法：渲染字符串    <strong>注意</strong>：v-text和v-html标签内的内容会被data变量里的数据所覆盖</li><li>v-html 会隐藏标签内容  官方叫法：既能渲染字符串，又能解析样式渲染出来</li><li>v-show  v-秀是通过控制css的display：none来控制元素的显示隐藏</li><li>v-if 是动态的向 DOM 树内添加或者删除 DOM 元素 控制JS 性能不好</li><li>当需要在显示与隐藏之间切片很频繁时，使用v-show<br>  当只有一次切换时，通过使用v-if</li><li>v-for 用法：v-for=”自己起的名 in 数组名” :key=”key.id”      注意：key后边必须加.id.id.id.id.id.id.id.id<ul><li>数组是下标，对象是key键</li><li>调用数组方法：如果这个方法操作后改变了原数组，那么列表会自动刷新</li><li>如果这个方法没有改变原数组，那么列表不会自动刷新</li><li>如果遍历复杂类型（对象），需要这么写 <li v-for="自己起的名 in list2" :key="自己起的名.name"></li></li><li>v-for添加key的作用：提高性能，标识渲染元素的唯一性，尽量少的操作DOM</li><li>修改中的值的方法：this.$set(数组,数组的索引,数组修改的值)</li></ul></li><li>在<strong>methods</strong>中，如果需要调用<strong>methods</strong>中<strong>已经定义的方法</strong>，需要加**this.**方法名</li><li>@绑定的方法后边可以加（实参）</li><li>methods里的方法第一个形参，可以打印出事件对象</li><li>为什么要加e，可以解决输入时:value绑定变量数据同步</li><li><strong>$event</strong>是指当前触发的是什么事件（鼠标事件，键盘事件等）</li><li><strong>$event.target.value</strong> 是指当你触发input事件时，$event 是当前的事件对象。 $event.target.value指向的是当前的input的值。</li><li>监听属性</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vue">watch: &#123;<br>  要监听的属性名 (newVal, oldVal)&#123; // 当msg变量的值改变触发此函数<br>    console.log(newVal, oldVal);<br>  &#125;<br></code></pre></td></tr></table></figure><h4 id="19-v-on（-）事件修饰符"><a href="#19-v-on（-）事件修饰符" class="headerlink" title="19.v-on（@）事件修饰符"></a><strong>19.v-on（@）事件修饰符</strong></h4><p>.stop 阻止事件冒泡</p><p>.prevent 阻止默认行为</p><p>.once 程序运行期间，只出发一次事件处理函数</p><p>.native 事件穿透（自定义组件绑定原生事件的时候）(比如键盘事件keyup)</p><p>有默认行为的元素：form元素 a元素</p><h4 id="20-v-model修饰符"><a href="#20-v-model修饰符" class="headerlink" title="20.v-model修饰符"></a><strong>20.v-model修饰符</strong></h4><p> .number 使用场景input 可以讲数字+字母的组合，转化为纯数字</p><p>.trim 首位去除空格 一般用于输入账号密码上</p><p>.lazy 懒加载 尽量让JS少的执行 提高性能 一般不用 除非有很多的表单时才使用</p><p>添加功能：先给input绑定v-model，之后添加数组方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">this</span>.list.unshift(&#123;<br><br>    <span class="hljs-attr">id</span>:<span class="hljs-built_in">Date</span>.now(),<br><br>    <span class="hljs-attr">name</span>:<span class="hljs-built_in">this</span>.name,<br><br>    <span class="hljs-attr">price</span>:<span class="hljs-built_in">this</span>.price,<br><br>    <span class="hljs-attr">time</span>:<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()<br><br>   &#125;)<br></code></pre></td></tr></table></figure><h4 id="21-常用功能"><a href="#21-常用功能" class="headerlink" title="21.常用功能"></a><strong>21.常用功能</strong></h4><p><strong>增加添加功能：</strong>this.tableData(表格名).push(this.inputData)</p><p><strong>删除功能</strong>：需要用到作用域插槽 参考文件 后台系统练习文件夹 employees-index.vue   this.list.splice(i, 1)</p><p>1.用户确认 避免误删除  this.$confirm</p><p>2.调用接口删除</p><p>3.刷新列表       this.getlist()</p><p><strong>编辑功能</strong>：数据回填+刷新列表 人资06-08</p><p>删除功能的坑：删除按钮需要用 <template slot-scope="scope"> 插槽包起来才可以获取到index</p><p><strong>全选反选功能</strong>，用!取反效果做  路径：基础-04-02</p><p><strong>检测键盘回车事件</strong>： @keyup.enter</p><p>删除接口的参数写在url路径上</p><p><img src="https://wushuo1031.oss-cn-beijing.aliyuncs.com/img/image-20211020123939497.png" alt="image-20211020123939497"></p><h4 id="22-计算属性和监听属性有什么区别-computed和watch有什么区别"><a href="#22-计算属性和监听属性有什么区别-computed和watch有什么区别" class="headerlink" title="22.计算属性和监听属性有什么区别(computed和watch有什么区别)"></a><strong>22.计算属性和监听属性有什么区别(computed和watch有什么区别)</strong></h4><p>计算属性（computed）：根据data中的数据，计算出一个新的数据，应用场景（在模板中渲染显示）</p><p>监听属性（watch）：只监听字符串的话，简单写法就行，监听对象等复杂数据类型，需要开启深度监听</p><p>计算属性一进入组件就会执行，然后监听属性只有数据发生改变才会执行。</p><p>计算属性有缓存，监听属性没有缓存，计算属性不支持异步，监听属性支持异步</p><p>计算属性应用场景：计算价格，计算总价</p><p>计算属性比methods计算性能要好，methods计算我试过会输出两次，而computed只会执行一次</p><p>methods（买涩死）也没有缓存</p><h4 id="23-组件注册"><a href="#23-组件注册" class="headerlink" title="23.组件注册"></a><strong>23.组件注册</strong></h4><p><strong>components</strong> 这个是组件注册的功能</p><p>全局注册</p><ul><li>1.import 要注册的组件页面</li><li>2.使用 Vue.component(‘TagName注册组件的标签名’,组件对象)</li></ul><p>局部注册</p><ul><li>1.在哪里用就在那里的sc标签import 导入       示范例：import zhedie from ‘../day01/折叠面板-练习.vue’</li><li>2.用几把里里 components这个函数注册，格式为对象：</li><li>components:{</li><li>标签名：标签组件对象</li><li>}     </li></ul><h4 id="24-组件通信"><a href="#24-组件通信" class="headerlink" title="24.组件通信"></a><strong>24.组件通信</strong></h4><p><strong>父传子用props</strong>：</p><p>1.在父组件的<strong>子组件标签</strong>上&lt;Child :自己起的名=”数据名”&gt;</Child>        绑定一个V-band</p><p>2.在 父组件data 下 定义要传的数据</p><p>3.切换到子组件，子组件的export 括号下 定义一个props数组</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-comment">// 子组件页面</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">  props:</span> &#123;<br>    <span class="hljs-comment">// 外边传给父部门的数据</span><br><span class="hljs-symbol">    currentNode:</span> &#123;<br><span class="hljs-symbol">      type:</span> Object,<br><span class="hljs-symbol">      default:</span> () =&gt; (&#123;&#125;)<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>4.之后就可以在div中，使用猴子语法绑定数据了。</p><p>注意：父组件传给儿子的数据，是<strong>单向数据流</strong>，props是只读的，不能修改</p><p><strong>子向父用this.$emit：</strong></p><p>1.父组件操作：定义自定义事件 @xiugai=”chuan”</p><p>2.子组件操作：绑定点击事件，使用 this.$emit(“父组件定义的自定义事件方法”, 任务(data里定义的名)名)    方法</p><p><strong>兄弟组件传值</strong>：</p><p>创建一个事件总线</p><p>引入第三方 new vue 定义为 eventBus </p><p>3.2）在组件中 created 中订阅方法 eventBus.$on(“自定义事件名”,methods 中的方法名) </p><p>3.3) 在另一个兄弟组件中的 methods 中写函数，在函数中发布 eventBus 订阅的方法 eventBus.$emit(“自定义事件名”) </p><p>3.4) 在组件的 template 中绑定事件(比如 click)</p><p>1.新建eventBus.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> Vue()<br></code></pre></td></tr></table></figure><p>2、Component1.vue里监听事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> eventBus <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./eventBus&#x27;</span><br><span class="hljs-comment">//...</span><br>created () &#123;<br>  eventBus.$on(<span class="hljs-string">&#x27;my-event&#x27;</span>, <span class="hljs-function"><span class="hljs-params">args</span> =&gt;</span> &#123;<br>  <span class="hljs-comment">//...</span><br>  &#125;) <br>&#125;<br></code></pre></td></tr></table></figure><p>3、Component2.vue中触发事件</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">import</span> eventBus from <span class="hljs-string">&#x27;./eventBus&#x27;</span><br><span class="hljs-comment">//...</span><br>watch: <span class="hljs-type"></span>&#123;<br>  list(<span class="hljs-keyword">new</span><span class="hljs-type">Value</span>, oldValue) &#123;<br>    eventBus.$emit(<span class="hljs-string">&#x27;my-event&#x27;</span>, <span class="hljs-keyword">new</span><span class="hljs-type">Value</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="25-简单类型和复杂类型"><a href="#25-简单类型和复杂类型" class="headerlink" title="25.简单类型和复杂类型"></a><strong>25.简单类型和复杂类型</strong></h4><p>1.简单类型：string，number等  放到<strong>栈</strong>中</p><p>2.复杂类型：函数，对象，数组     放到 堆中</p><p>一句话总结： 简单栈，复杂堆，微宏工程师</p><h4 id="26-Vue-配置文件配置"><a href="#26-Vue-配置文件配置" class="headerlink" title="26.Vue 配置文件配置"></a><strong>26.Vue 配置文件配置</strong></h4><p>规范错误不会出小黑框：lintOnSave:true</p><h4 id="27-Axios"><a href="#27-Axios" class="headerlink" title="27.Axios"></a><strong>27.Axios</strong></h4><p>两种方式拿结果，第一种.then</p><p>.then()方法是异步执行。</p><p>url：接口地址</p><p>method：请求类型</p><p>第一种：<strong>async</strong> 写在 方法蓝色字体的前面 ， <strong>await</strong> 写在 等号的 后面</p><p>第二种：<strong>async</strong>写在箭头函数圆括号的前边，<strong>await</strong>写在调接口的蓝色this前边</p><h4 id="28-Vue生命周期"><a href="#28-Vue生命周期" class="headerlink" title="28.Vue生命周期"></a><strong>28.Vue生命周期</strong></h4><p>mounted钩子函数，可以操作DOM  这个也能发请求 不过比created慢</p><p>created钩子函数，可以发请求</p><p>Vue3取消了created，只能在mounted里发送</p><h4 id="29-动态组件"><a href="#29-动态组件" class="headerlink" title="29.动态组件"></a><strong>29.动态组件</strong></h4> <component :is="dangqian" /><p>  &lt;button @click=”dangqian=’Dy1’”&gt;dy1</button></p><p>  &lt;button @click=”dangqian=’Dy2’”&gt;dy2</button></p><p>Keep-live 组件缓存后会多两个钩子函数 ： activated  deactivated 阿克地位踢德 滴阿克地位踢德</p><h4 id="30-移动端适配"><a href="#30-移动端适配" class="headerlink" title="30.移动端适配"></a><strong>30.移动端适配</strong></h4><p>需要两个npm插件：</p><ul><li><a href="https://github.com/cuth/postcss-pxtorem">postcss-pxtorem</a> 将 px 单位转化为 rem 单位</li><li><a href="https://github.com/amfe/lib-flexible">lib-flexible</a> 用于动态设置 rem 基准值（随着屏幕的方法缩小，动态px）</li></ul><h4 id="31-Vue自定义指令"><a href="#31-Vue自定义指令" class="headerlink" title="31.Vue自定义指令"></a><strong>31.Vue自定义指令</strong></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">Vue.directive(<span class="hljs-string">&#x27;指令名&#x27;</span>,&#123;<br><br><span class="hljs-comment">//指令的逻辑</span><br><br><span class="hljs-function"><span class="hljs-title">inserted</span>(<span class="hljs-params">el</span>)</span>&#123;<br><br>el.style.color = <span class="hljs-string">&#x27;pink&#x27;</span><br><br>&#125;<br><br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="32-Vue路由自学"><a href="#32-Vue路由自学" class="headerlink" title="32.Vue路由自学"></a><strong>32.Vue路由</strong>自学</h4><p>在router文件夹-index.js文件里进行配置</p><p>1.导入页面</p><p>2.往routes数组里加对象{path:’页面跳转路径’,component:组件对象}</p><p>静态路由：没有访问限制的页面</p><p>动态路由：需要权限才可以访问的页面</p><p>链接导航：<router-link to="/home">首页</router-link></p><p>this.$router.push() 作用：</p><ul><li><p><strong>this.$router.push() 可以通过修改url实现路由跳转。</strong></p></li><li><p><strong>this.$router.back() 可以实现返回上一页</strong></p></li><li><p>push 后面可以是对象，也可以是字符串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jade">// 字符串 this.$router.push(&#x27;/home/first&#x27;)``<br>// 对象 this.$router.push(&#123; path: &#x27;/home/first&#x27; &#125;)``<br>// 命名的路由 this.$router.push(&#123; name: &#x27;home&#x27;, params: &#123; userId: wise &#125;&#125;)<br></code></pre></td></tr></table></figure></li></ul><p><strong>路由传参</strong>：动态路由可以通过冒号携带参数    使用场景：发请求，页面之间通信</p><p><strong>接收路由传参</strong>：</p><p>1、?形式的参数使用this.$route.query接收参数，结果是一个对象 </p><p>2、:形式的参数使用this.$route.params接收参数，结果也是一个对象 </p><ul><li>query  <strong>/路径?a=xxx&amp;b=xxx</strong>       传：在router-link的 to 后边传  <strong>接收</strong>：created钩子函数接收 this.$route.query   完结了  刷新还在</li><li><img src="https://wushuo1031.oss-cn-beijing.aliyuncs.com/img/image-20211031142716627.png" alt="image-20211031142716627"></li><li>params啪若母传参 需要加上name    刷新没有了</li><li><img src="https://wushuo1031.oss-cn-beijing.aliyuncs.com/img/image-20211031142333909.png" alt="image-20211031142333909"></li><li>用法1（路由文件）在path后边 加上 /:参数名1/:参数名2     （动态路由=&gt; 详情页）         使用场景：详情页面</li><li>用法1（Vue文件） to后边写参数</li><li><strong>接收</strong>：this.$route.params</li></ul><p>路由重定向：redirect:’/home’  这行代码代表 用户什么都不输入 跳转到首页</p><p>路由404配置（记得导入404页面）：{</p><p>path:’*’,</p><p>component:NotFound</p><p>}</p><p><strong>切换路由模式</strong>：在实例化路由的对象下边，加一个mode属性，mode:’history’</p><p><strong>编程式导航</strong>：this.$router.push()</p><ul><li>第一种用法 this.$router.push(‘/about’)      使用场景：可以用作按钮跳转</li><li>第二种写法：对象模式  this.$router.push({ path: ‘/路径名’ })</li><li>第三种写法： name  需要先去路由js页面的对象数组里，定义一个name 然后在需要的页面使用 this.$router.push({ name: ‘/起的name名’ })</li><li>拓展：返回上级页面：不用加this，@click=”$router.back()”</li><li>@click=”$router.go()” 什么都不传是刷新，传-1是返回上个页面</li></ul><p><strong>路由嵌套（配置二级路由）</strong></p><ul><li>导入所有的二级路由页面（index.js）</li><li>找到父页面，在父页面对象下，写一个children:[{里边配置和正常一样，也是放一个对象}]  </li><li>子路由的path为空或者和父路由的path一样，会默认加载渲染当前这个二级路由</li><li>children:[{</li><li>path:’/父path/子path’</li><li>component:子路由名</li><li>}]</li><li>然后，放挂载点router-view标签 放到儿子的父页面</li><li>之后，就可以使用router-link 加个 to 跳转了</li></ul><p>路由方法：router.replace</p><h4 id="33-SPA单页面富应用"><a href="#33-SPA单页面富应用" class="headerlink" title="33.SPA单页面富应用"></a><strong>33.SPA单页面富应用</strong></h4><p>优点：用户体验好，开发效率高，静态资源共用，组件化开发，页面刷新时是局部刷新</p><p>缺点：第一次打开速度慢，不利于SEO优化，需要通过SSR服务端渲染提高打开速度</p><p><strong>头条登录功能</strong>：</p><p>1.先拿到用户输入的数据 </p><p>2.封装一个登录的API接口 </p><p>3.async await 调用接口</p><p>4.把token存储到本地（涉及知识点，本地存储；localStorage.setItem(‘token’, JSON.stringify(res.data) )</p><p>5.跳转到首页</p><p>6.把陶肯存储到Vuex中</p><p>7.<strong>表单校验</strong>，用的饿了么UI内置的校验规则</p><h4 id="34-人资项目关键点："><a href="#34-人资项目关键点：" class="headerlink" title="34.人资项目关键点："></a><strong>34.人资项目关键点：</strong></h4><p>静态路由：用户不需要权限判断都可以访问的</p><p>动态路由：需要做权限控制的路由，用户如果权限不一致访问到的路由也不一样</p><ul><li>登录后，拿到权限点数据</li><li>根据权限点数据，过滤动态路由  asyncRoutes.filter方法</li><li>获取路由配置的name和登录人的menus数组中的值匹配     return points.menus.includes(route.children[0].name)  </li><li>动态添加路由生效   router.addRoutes([…filterAsyncRoutes, { path: ‘*’, redirect: ‘/404’, hidden: true }])</li></ul><p><strong>1.登录功能</strong></p><p><strong>HTML结构三大组成部分</strong>：el-form表单校验  el-form-item 表单项  el-button 提交按钮</p><p>el-form-item 里的 prop是校验用的</p><p><strong>绑定：</strong></p><p>1.el-form绑定model属性/rules规则    :model绑定手机号密码的data数据     :rules 绑定的是校验规则</p><p>2.el-form-item设置prop属性  prop属性设置的是手机号密码，也就是mobile和password</p><p>3.el-input v-毛豆绑定属性</p><p><strong>校验：</strong></p><p>密码用min max控制密码长度，message为输入密码的提示信息，trigger：’blur’为失去焦点</p><p>手机号用函数（validator）校验，封装正则校验方法，导入进登录页面，形参写value，三个形参(rule, value, callback) ，</p><p>封装<strong>登录组件</strong>api/user.js 固定格式 导入import进登录页</p><p>配置baseURL并调用接口 </p><p><strong>2.Token存储</strong></p><p>1.在store-modules创建了一个user.js文件 用来存储Token</p><p>2.在state里定义一个token:getToken() || ‘’，    // 意思是先读取，读取不到就是空</p><p>在Mutation中定义存储Token，删除Token的方法</p><p><img src="https://wushuo1031.oss-cn-beijing.aliyuncs.com/img/image-20210905001848032.png" alt="image-20210905001848032"></p><p>3.存储Token到Vuex，步骤首先返回登录的Vue文件，然后使用this.$store.commit(‘user/updateToken’,res)</p><p>​      //形参：模块名/方法名，res</p><p>4.<strong>持久化存储Token</strong>   js-cookie插件</p><ul><li>设置TokenKey键                                                                                                                                     </li><li>Vuex的Mutation里加代码，本地存一份，setToken(token)</li><li>导入存储和删除的import</li><li>添加本地删除的代码，removeToken()</li><li>存完以后，加跳转首页逻辑，this.$router.replace(‘/‘)</li></ul><p>5.Token权限拦截（router.beforeEach），有Token调回首页，没有Token调回登录页</p><ul><li>创建permission.js</li><li>导入路由实例 导入vuex实例</li><li>创建白名单数组</li><li>添加前门保安，根据是否有Token拦截页面的访问，router.beforeEach((to,from,next) =&gt;{</li><li>if else 判断是否有Token</li><li>})</li></ul><p><img src="https://wushuo1031.oss-cn-beijing.aliyuncs.com/img/image-20210905213656666.png" alt="image-20210905213656666"></p><p>登出功能：</p><ul><li>提示用户是否要登出（使用饿了么messagebox弹框组件）</li><li>清除Token，清除用户信息</li><li>跳转到登录页</li></ul><p><strong>Token失效</strong>功能：</p><ul><li>访问某个接口时，后端检查当前token是否失效</li><li>如果token已经失效，返给前端的是<strong>http状态码401</strong></li><li>前端通过<strong>返回拦截器的错误回调</strong>捕获401，进行登出操作</li></ul><p>响应拦截器- request.js-  优化登录，处理请求错误，解构赋值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js">response =&gt; &#123;<br>    <span class="hljs-comment">// 请求成功进入这里</span><br>   <span class="hljs-keyword">const</span> &#123; success, data, message &#125; = response.data<br>   <span class="hljs-comment">// 处理请求的成功或者失败</span><br>   <span class="hljs-keyword">if</span> (success) &#123;<br>       <span class="hljs-comment">// 成功就把页面需要的data返回</span><br>     <span class="hljs-keyword">return</span> data<br>   &#125; <span class="hljs-keyword">else</span> &#123;<br>     <span class="hljs-comment">// 请求失败</span><br>     Message(&#123;<br>       message,<br>       <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;error&#x27;</span>,<br>       <span class="hljs-attr">duration</span>: <span class="hljs-number">4</span> * <span class="hljs-number">1000</span><br>     &#125;)<br>     <span class="hljs-comment">// 错误的话中断请求</span><br>     <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(message))<br>   &#125;<br></code></pre></td></tr></table></figure><p>持久化存储token：判断是不是401，如果是401的话，清除token，强制跳转登录页，重新登陆获取token</p><p>动态路由和静态路由都有一个数组，需要使用展开运算符对这两个数组进行合并。</p><p>el-card 可以作为容器组件div进行使用</p><p>:default-expand-all=”true”  默认开启所有tree组件 默认展开所有</p><p><strong>scss SCSS样式穿透–深度作用选择符 =》 ::v-deep</strong></p><h4 id="35-原型链"><a href="#35-原型链" class="headerlink" title="35.原型链"></a><strong>35.原型链</strong></h4><ul><li>prototype 原型</li><li>_ _photo原型链</li></ul><p>当访问一个对象的某个属性的时候，会先在这个对象本身的属性上找，如果没有找到，会去这个属性的__proto属性上找，即这个构造函数的prototype，如果还没有找到，会继续在–proto上查找，直到最顶层，找不到即为undefined。这样一层一层往上找，仿佛是一条链子穿起来，就叫做原型链</p><h4 id="36-作用域链"><a href="#36-作用域链" class="headerlink" title="36.作用域链"></a><strong>36.作用域链</strong></h4><p>变量取值会到创建这个变量的函数作用域中取值，如果找不到，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链</p><h4 id="37-原型链和作用域链的区别？"><a href="#37-原型链和作用域链的区别？" class="headerlink" title="37.原型链和作用域链的区别？"></a><strong>37.原型链和作用域链的区别？</strong></h4><p>作用域是对变量而言，原型链是对于对象的属性而言</p><p>作用域链的最顶层是window，原型链的最顶层是object </p><h4 id="38-Vue的双向绑定的原理"><a href="#38-Vue的双向绑定的原理" class="headerlink" title="38.Vue的双向绑定的原理"></a><strong>38.Vue的双向绑定的原理</strong></h4><p>　Vue是采用<strong>数据劫持</strong>结合<strong>发布订阅</strong>模式的方式，通过<code>Object.defineProperty()</code>来劫持各个属性的<code>setter</code>，<code>getter</code>，</p><p>​    并在数据变动时发布消息给订阅者，触发相应的监听回调。</p><h4 id="39-事件循环机制"><a href="#39-事件循环机制" class="headerlink" title="39.事件循环机制"></a><strong>39.事件循环机制</strong></h4><p>JS执行是单线程的，代码会一行一行往下执行，在JS执行时，只要遇到了异步的函数，不会停留，会将异步函数交给浏览器。</p><p>同步代码执行完了执行异步，异步代码又分为宏任务和微任务</p><p>宏任务有:setTimeout、setInterval、script(整体代码)等</p><p>微任务有：Promise async await</p><h4 id="40-重绘和回流"><a href="#40-重绘和回流" class="headerlink" title="40.重绘和回流"></a><strong>40.重绘和回流</strong></h4><p>重绘：比如修改了网页的背景颜色，只影响了元素的外观，不影响布局的叫做重绘</p><p>回流：当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流</p><p>区别：重绘不一定会导致回流，但是回流一定会重绘</p><ul><li>重排是指部分渲染树（或者整个渲染树）需要重新分析并且节点尺寸需要重新计算；</li><li>重绘是由于节点的几何属性发生改变或者由于样式发生改变，例如改变元素背景色时，屏幕上的部分内容需要更新。</li></ul><h4 id="41-解决跨域的方式有哪些"><a href="#41-解决跨域的方式有哪些" class="headerlink" title="41.解决跨域的方式有哪些"></a>41.解决跨域的方式有哪些</h4><p>跨域只发生在浏览器中，我一般使用proxy代理进行跨域，里边有一个target属性，直接填接口地址就可以了</p><p>JSONP 只支持GET请求，不支持POST请求。</p><h4 id="42-vue-router怎样实现页面跳转"><a href="#42-vue-router怎样实现页面跳转" class="headerlink" title="42.vue-router怎样实现页面跳转"></a><strong>42.vue-router怎样实现页面跳转</strong></h4><p>实现Vue路由跳转有两种模式，一种是哈希模式，一种是history 模式</p><p>这两个模式在URL地址栏的表现不同，其中最大的区别就是哈希模式会在后边带一个#号，history 模式则没有井号。</p><p>哈希模式的兼容性更好，</p><h4 id="43-解释一下JS的同源策略"><a href="#43-解释一下JS的同源策略" class="headerlink" title="43.解释一下JS的同源策略"></a>43.解释一下JS的同源策略</h4><p>协议，域名，端口号相同，同源策略是一种安全协议。</p><h4 id="44-如何实现数组的去重"><a href="#44-如何实现数组的去重" class="headerlink" title="44.如何实现数组的去重"></a>44.如何实现数组的去重</h4><p>我一般使用ES6里边的new Set实现数组去重。</p><p>let 一个新数组传入旧数组，log新数组即可得到去重的结果。</p><ul><li>双层循环</li><li>IndexOf和includes</li><li>排序去重</li><li>Filter方法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 通过ES6的new Set进行数组去重：</span><br><br><span class="hljs-comment">// 1. 数字、字符串数组去重</span><br><span class="hljs-keyword">let</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>];<br><span class="hljs-keyword">let</span> newArr1 = [...new <span class="hljs-built_in">Set</span>(arr1)];<br><span class="hljs-built_in">console</span>.log(newArr1);<br><span class="hljs-comment">// [1, 2, 3, &#x27;1&#x27;]</span><br><br><span class="hljs-comment">// 2. 对象数组去重</span><br><span class="hljs-keyword">let</span> arr2 = [<br>  &#123;<span class="hljs-attr">a</span>: <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-attr">b</span>: <span class="hljs-string">&#x27;q&#x27;</span>&#125;,<br>  &#123;<span class="hljs-attr">a</span>: <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-attr">b</span>: <span class="hljs-string">&#x27;q&#x27;</span>&#125;,<br>  &#123;<span class="hljs-attr">a</span>: <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-attr">b</span>: <span class="hljs-string">&#x27;e&#x27;</span>&#125;,<br>  &#123;<span class="hljs-attr">a</span>: <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-attr">b</span>: <span class="hljs-string">&#x27;e&#x27;</span>&#125;<br>]<br><span class="hljs-keyword">let</span> newArr2 = [...new <span class="hljs-built_in">Set</span>(arr2.map(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-built_in">JSON</span>.stringify(e)))].map(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-built_in">JSON</span>.parse(e))<br><span class="hljs-built_in">console</span>.log(newArr2);<br><span class="hljs-comment">// [&#123;a: &#x27;1&#x27;, b: &#x27;q&#x27;&#125;, &#123;a: &#x27;2&#x27;, b: &#x27;e&#x27;&#125;]</span><br></code></pre></td></tr></table></figure><h4 id="45-说明常见的状态码，并且说明含义"><a href="#45-说明常见的状态码，并且说明含义" class="headerlink" title="45.说明常见的状态码，并且说明含义"></a><strong>45.说明常见的状态码，并且说明含义</strong></h4><p>200 成功</p><p>3XX 一般代表重定向，一般域名的后台设置也有3XX这个状态码</p><p>4XX 一般是请求错误 常见的有401 和 404</p><p>5XX 这个一般就是服务器端发送过来的错误了</p><h4 id="46-对async-await的理解"><a href="#46-对async-await的理解" class="headerlink" title="46.对async/await的理解"></a><strong>46.对async/await的理解</strong></h4><p>异步编程的最高境界就是不关心它是否是异步。async、await很好的解决了这一点，将异步强行转换为同步处理。</p><p>async/await与promise不存在谁代替谁的说法，因为async/await是寄生于Promise，是Generater(占牛瑞特)的语法糖。</p><h4 id="47-ES6新特性"><a href="#47-ES6新特性" class="headerlink" title="47.ES6新特性"></a><strong>47.ES6新特性</strong></h4><p>我简单列举几个吧：let关键字，const关键字，模板字符串，箭头函数，解构赋值，…展开运算符（使用场景：mapstate，map谬忒神），promise对象等等</p><h4 id="48-和-的区别？"><a href="#48-和-的区别？" class="headerlink" title="48.=== 和 ==的区别？"></a><strong>48.=== 和 ==的区别？</strong></h4><p>=== ：不仅需要值相同，数据类型也相同时才能返回true</p><p>== ：两个等号只要值相等就可以，数据类型不同会存在隐式转换</p><h4 id="49-请简述一下Vuex的原理，和使用方法"><a href="#49-请简述一下Vuex的原理，和使用方法" class="headerlink" title="49.请简述一下Vuex的原理，和使用方法"></a><strong>49.请简述一下Vuex的原理，和使用方法</strong></h4><p>Vuex存储，dispatch和commit的区别，dispatch: 含有异步操作，commit：同步操作</p><p>Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>，可以方便的实现组件之间数据的共享</p><p>一般只有，组件之间需要共享的数据，才有必要存到Vuex中，对于组件内的私有数据，依旧存储到组件data中</p><p><strong>调用Vuex有两种方法</strong>，一种是…mapState，一种是this.$store.state(获取数据)，this.$store.commit(‘方法名’,payload) – 修改数据</p><p>this.$store.dispatch(‘方法名’,payload) – 调接口</p><p><strong>State</strong>（store.js），state本质上是一个对象，作用是用来存储全局共享的数据。</p><ul><li>组件访问State中数据的<strong>第一种方式</strong> this.$store.state.全局数据名称</li></ul><p>访问State中数据的<strong>第二种方式</strong>：</p><ul><li>在子组件导入mapstate函数  import {mapState} from ‘vuex’</li><li>将全局数据，映射为当前组件的计算属性</li><li>computed:{</li><li>…mapState([‘count’])</li><li>}</li><li>之后就可以用，插值表达式进行渲染了</li></ul><p><strong>Mutation</strong>（store.js）：专门负责修改State<strong>中的数据</strong></p><ul><li>Mutation的形参，第一个永远是state，第二个形参可以定义变量在commit中用</li><li><strong>this.$store.commit(</strong>‘路径’,第二个形参可以自定义) 进行触发 (也可以说是调用谬忒神的方法)</li></ul><p><img src="https://wushuo1031.oss-cn-beijing.aliyuncs.com/img/image-20210912162421077.png" alt="image-20210912162421077"></p><p>触发<strong>Mutation</strong>的第二种方式：</p><ul><li>（子组件）从vuex中引入mapMutation</li><li>（子组件）…mapMutations([‘方法名’])</li><li>（子组件）使用this.方法名() 调用</li></ul><p><img src="https://wushuo1031.oss-cn-beijing.aliyuncs.com/img/image-20210912173426616.png" alt="image-20210912173426616"></p><p><strong>action</strong> 啊可神 本质上是一个JS函数，专门用来处理Vuex中的异步操作。不能修改数据源</p><ul><li>在action中不能直接修改state中的数据</li><li>要修改必须通过context.commit(‘Mutation中定义的方法’)触发某个谬忒神才行</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">（store.js）<br><br><span class="hljs-attr">actions</span>:&#123;<br> add异步(context) &#123;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span> &#123;<br> context.commit(<span class="hljs-string">&#x27;Mutation定义的方法&#x27;</span>)<br>&#125;,<span class="hljs-number">1000</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>调用action的方法(子组件)</li><li><strong>this.$store.dispatch</strong>(‘add异步名’)  进行触发action</li></ul><p><strong>Getter</strong>本质上是JS函数。作用：它是Vuex中的计算属性，当Store数据源发生变化，Getter的返回值会自动更新。</p><ul><li>使用方法：this.$store.getters.名称</li></ul><p><strong>Module</strong>  猫肘 模块化开发，注册组件用</p><p>键盘敲 Vmod 快速生成VueX 代码 </p><p>namespaced: true 开启Vuex 命名空间</p><p>store.dispatch：含有异步操作，例如向后台提交数据，写法： this.$store.dispatch(‘mutations方法名’,值)</p><p>store.commit：同步操作，写法：this.$store.commit(‘mutations方法名’,值)</p><h4 id="50-简述弹性盒子flex布局及rem布局"><a href="#50-简述弹性盒子flex布局及rem布局" class="headerlink" title="50.简述弹性盒子flex布局及rem布局"></a><strong>50.简述弹性盒子flex布局及rem布局</strong></h4><p>开启flex布局只需在最外层容器设置**display:flex;**即可</p><p>整个网页可以看做是一个flex容器</p><p>里边的子容器可以称之为flex成员</p><p>容器默认存在两根轴，一个水平轴，一个交叉轴</p><p>​    justify-content: center; /* 水平居中 */</p><p>​    align-items: center; /* 垂直居中 */</p><p>Flex是css中一种布局手段，主要用来代替浮动，flex可以使元素具有弹性，让元素可以跟随页面的大小的改变而改变；</p><p>弹性容器和弹性元素</p><p>容器属性有flex-direction，flex-wrap换行，justify-content分配空白</p><p>元素属性有flex-grow伸展系数、flex-shrimk收缩系数、flex-basis基础长度、order排列顺序</p><h4 id="51-nextTick在Vue最新的版本中是微任务。"><a href="#51-nextTick在Vue最新的版本中是微任务。" class="headerlink" title="51.$nextTick在Vue最新的版本中是微任务。"></a><strong>51.$nextTick在Vue最新的版本中是微任务。</strong></h4><h4 id="52-Vue页面强制刷新：this-router-go-0"><a href="#52-Vue页面强制刷新：this-router-go-0" class="headerlink" title="52.Vue页面强制刷新：this.$router.go(0)"></a><strong>52.Vue页面强制刷新：this.$router.go(0)</strong></h4><h4 id="53-解构赋值：把对象中的内容赋值给变量"><a href="#53-解构赋值：把对象中的内容赋值给变量" class="headerlink" title="53.解构赋值：把对象中的内容赋值给变量"></a><strong>53.解构赋值：把对象中的内容赋值给变量</strong></h4><h4 id="54-Vue如何封装一个组件封装组件"><a href="#54-Vue如何封装一个组件封装组件" class="headerlink" title="54.Vue如何封装一个组件封装组件"></a><strong>54.Vue如何封装一个组件封装组件</strong></h4><ol><li>在compoents文件夹中新建一个vue文件（以dialog弹层组件为例）</li><li>在main.js中全局引入，先import再注册到VUE中</li><li>接着就可以在任何页面直接使用自己定义的组件</li></ol><h4 id="55-什么是websocket"><a href="#55-什么是websocket" class="headerlink" title="55.什么是websocket?"></a><strong>55.什么是websocket?</strong></h4><p>websocket是H5的一个新协议，它允许服务端向客户端传递信息，实现浏览器和客户端双工通信</p><h4 id="56-Vue-性能优化"><a href="#56-Vue-性能优化" class="headerlink" title="56.Vue 性能优化"></a>56.Vue 性能优化</h4><ul><li>对象层级不要过深，否则性能就会差</li><li>v-for 遍历必须加 key，key 最好是 id 值，且避免同时使用 v-if</li><li>防止内部泄漏，组件销毁后把全局变量和事件销毁</li><li>图片懒加载</li><li>路由懒加载</li><li>第三方插件的按需引入</li><li>适当采用 keep-alive 缓存组件   keep-alive使用场景: 商品列表页点击商品跳转到商品详情，返回后仍显示原有信息</li><li>防抖、节流运用</li><li>服务端渲染 SSR or 预渲染</li></ul><h4 id="57-Vue组件中的data为什么必须是一个函数"><a href="#57-Vue组件中的data为什么必须是一个函数" class="headerlink" title="57.Vue组件中的data为什么必须是一个函数"></a><strong>57.Vue组件中的data为什么必须是一个函数</strong></h4><p>每一个实例的data属性都是独立的，是一个独立的作用域，不会相互影响</p><p>这都是因为js本身的特性带来的，跟vue本身设计无关</p><h4 id="58-null和undefined的区别"><a href="#58-null和undefined的区别" class="headerlink" title="58.null和undefined的区别"></a>58.null和undefined的区别</h4><p>两等等于true 三等等于false</p><p>Null类型，代表“空值”，代表一个空对象指针</p><p>undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。</p><h4 id="59-this指向"><a href="#59-this指向" class="headerlink" title="59.this指向"></a><strong>59.this指向</strong></h4><p>在函数中调用 指向window</p><p>在对象中电泳 this指向这个函数的对象</p><p>在构造函数中指向new的对象</p><p>call apply bind 中 指向第一个参数</p><p>箭头函数没有this 他的this是继承来的</p><p>vue中的this指向：Vue文档里的原话是：在Vue所有的生命周期钩子方法（如created，mounted， updated以及destroyed）里使用this，this指向调用它的Vue实例，即（new Vue）。 </p><h4 id="60-路由守卫（路由钩子）"><a href="#60-路由守卫（路由钩子）" class="headerlink" title="60.路由守卫（路由钩子）"></a><strong>60.路由守卫（路由钩子）</strong></h4><p>全局<strong>前置</strong>守卫 router.beforeEach((to, from, next)=&gt;{</p><p>})</p><p>to 是去哪 from来自哪里</p><p>全局<strong>后置</strong>守卫 router.afterEach()         使用场景：页面访问统计，数据采集</p><p>路由每个对象内的 beforeEnter</p><p>某个组件内的：进入路由 beforeRouteEnter  离开路由 beforeRouteLeave</p><p>三个形参 to from next </p><p>to要进入的路由 from从哪里来的 是否可以访问这个页面</p><p>next() 代表什么页面都能访问</p><p>怎么判断用户是否可以登录呢？=》通过登录接口 获取的token做判断</p><p><strong>全局前置守卫 router.beforeEach() 拦截实战</strong></p><p>需求：我的页面，需要登录才能访问，其他页面直接放行</p><p>解决：if(to.path === ‘/my’ &amp;&amp; !localStorage.getItem(‘token名称’)) {</p><p>alert(‘请登录’)</p><p>} else {</p><p> next()</p><p>}</p><p>============================================================</p><h4 id="61-块级元素和行内元素"><a href="#61-块级元素和行内元素" class="headerlink" title="61.块级元素和行内元素"></a><strong>61.块级元素和行内元素</strong></h4><p>块级元素独占一行 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>...<span class="hljs-tag">&lt;<span class="hljs-name">h6</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span>、<span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><p>行内元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">span，a，img，input <br></code></pre></td></tr></table></figure><h4 id="62-Css选择器有哪些，优先级？"><a href="#62-Css选择器有哪些，优先级？" class="headerlink" title="62.Css选择器有哪些，优先级？"></a>62.Css选择器有哪些，优先级？</h4><p>优先级：内联样式 &gt; id选择器 &gt; 类和伪类选择器 &gt; 元素选择器 &gt; 通配选择器</p><p>有哪些：id选择器，类选择器，标签选择器，后代选择器，子代选择器</p><p>优先级：!important &gt; 内联样式 &gt; id选择器 &gt; 类、伪类、属性选择器 &gt; 标签、伪元素选择器</p><h4 id="63-for-in-和-for-of的区别"><a href="#63-for-in-和-for-of的区别" class="headerlink" title="63.for in 和 for of的区别"></a>63.for in 和 for of的区别</h4><p>for…in 循环：只能获得对象的键名，不能获得键值  for…in 循环主要是为了遍历对象而生，不适用于遍历数组</p><p>for…of 循环：允许遍历获得键值 for…of 循环可以用来遍历数组、类数组对象，字符串</p><h4 id="64-element-ui-自定义主题修改"><a href="#64-element-ui-自定义主题修改" class="headerlink" title="64.element-ui 自定义主题修改"></a>64.element-ui 自定义主题修改</h4><p>1.先把主题去饿了么UI官网下载下来</p><p>2.把theme页面放到vue项目里，assest里面</p><p>3.main.js中引入</p><h4 id="65-如何判断js中的数据类型"><a href="#65-如何判断js中的数据类型" class="headerlink" title="65.如何判断js中的数据类型"></a><strong>65.如何判断js中的数据类型</strong></h4><p>1.使用typeof操作符  typeof不适合用于判断是否为数组。当使用typeof判断数组和对象的时候，都会返回object。</p><ol start="2"><li>instanceof   instanceof只能用来判断对象和函数，不能用来判断字符串和数字等。判断它是否为字符串和数字时，只会返回false</li><li>prototype  以上三种方法多少都会有一些不能判断的情况。为了保证兼容性，可以通过<strong>Object.prototype.toString</strong>方法，判断某个对象值属于哪种内置类型。（）</li><li><a href="https://www.cnblogs.com/yi0921/p/6183422.html">https://www.cnblogs.com/yi0921/p/6183422.html</a></li></ol><h4 id="66-json和json字符串如何转换"><a href="#66-json和json字符串如何转换" class="headerlink" title="66.json和json字符串如何转换"></a>66.json和json字符串如何转换</h4><p>JavaScript 函数 <strong>eval()</strong> 可用于将 JSON 文本转换为 JavaScript 对象。</p><p>JSON对象转换为字符串 通过<strong>JSON.stringify</strong> 函数转换为字符串 </p><h4 id="67-定位的方式-相对于谁定的"><a href="#67-定位的方式-相对于谁定的" class="headerlink" title="67.定位的方式 相对于谁定的"></a>67.定位的方式 相对于谁定的</h4><p>绝对定位，他是参照浏览器的左上角，配合TOP、RIGHT、BOTTOM、LEFT(下面简称TRBL)进行定位，在没有设定TRBL，默认依据父级的做标原始点为原始点。</p><h4 id="68-var与let、const的区别"><a href="#68-var与let、const的区别" class="headerlink" title="68.var与let、const的区别"></a>68.var与let、const的区别</h4><ul><li>var声明变量存在变量提升，let和const不存在变量提升</li><li>let和const声明形成块作用域</li><li>同一作用域下let和const不能声明同名变量，而var可以</li><li>const只能定义常量</li></ul><h4 id="69-span元素给宽和高之后宽高是多少-给margin之后是多少："><a href="#69-span元素给宽和高之后宽高是多少-给margin之后是多少：" class="headerlink" title="69.span元素给宽和高之后宽高是多少 给margin之后是多少："></a>69.span元素给宽和高之后宽高是多少 给margin之后是多少：</h4><p>span元素属于行内元素，当我们直接设置了宽度和高度的时候，不会生效</p><p>在样式属性中添加display:block 即可生效</p><p>inline-block: 既有inline的同行特性，又有block的宽度和高度特性。</p><h4 id="70-DOM事件流的三个阶段"><a href="#70-DOM事件流的三个阶段" class="headerlink" title="70.DOM事件流的三个阶段"></a>70.DOM事件流的三个阶段</h4><p>捕获阶段：事件从Document节点自上而下向目标节点传播的阶段；</p><p>目标阶段：真正的目标节点正在处理事件的阶段；</p><p>冒泡阶段：事件从目标节点自上而下向Document节点传播的阶段。</p><h4 id="71-盒子垂直水平居中"><a href="#71-盒子垂直水平居中" class="headerlink" title="71.盒子垂直水平居中"></a>71.盒子垂直水平居中</h4><p><strong>宽度和高度已知的情况下</strong></p><p>1.给父元素相对定位<br>给子元素绝对定位<br>left: 50%;top: 50%;<br>margin-left: 负的宽度一半。<br>margin-top: 负的高度一半；</p><p><strong>宽度和高度自己未知的情况下</strong><br>思路：<br>给父盒子相对定位<br>给子盒子绝对定位<br>top、right、bottom、left全为0<br>margin: auto;</p><h4 id="72-JS继承"><a href="#72-JS继承" class="headerlink" title="72.JS继承"></a>72.JS继承</h4><p><strong>组合继承（常用！组合原型链继承和借用构造函数继承）</strong></p><p><strong>寄生组合式继承（常用）</strong></p><p><strong>原型链继承</strong>：让新实例的原型等于父类的实例</p><p><strong>构造函数继承</strong>：用.call()和.apply()将父类构造函数引入子类函数</p><p><strong>class继承</strong></p><h4 id="73-ajax请求的时候get和post方式的区别"><a href="#73-ajax请求的时候get和post方式的区别" class="headerlink" title="73.ajax请求的时候get和post方式的区别"></a>73.ajax请求的时候get和post方式的区别</h4><p>一个在url后面 ，一个放在虚拟载体里面<br>get有大小限制(只能提交少量参数)<br>安全问题 一个加密一个不加密<br>应用不同 ，请求数据和提交数据</p><p>Get</p><ul><li>一般用于获取数据</li><li>基于URL地址传参，所以有个长度限制（一般在8kb），如果超过就会被截掉</li><li>因为get请求基于问号传参容易被劫持，所以相对不安全</li><li>会产生不可控的缓存，POST不会</li></ul><p>Post</p><ul><li>一般用于新增数据</li><li>基于请求传参，理论上没有任何限制（真实项目中会自己做大小限制，防止上传过在信息导致请求迟迟完不成）</li><li>POST请求基于请求主体传参，相对来说不好被劫持，比较安全</li></ul><h4 id="74-没有宽高的盒子水平垂直居中的效果的方法"><a href="#74-没有宽高的盒子水平垂直居中的效果的方法" class="headerlink" title="74.没有宽高的盒子水平垂直居中的效果的方法"></a>74.没有宽高的盒子水平垂直居中的效果的方法</h4><p>方法一、CSS+定位</p><p>让其父元素相对定位，内部元素绝对定位，这里的父元素为body。<br>　　原理：让未定义宽高的图片上下左右距离都为0.然后给一个margin自适应。可以想象成一个盒子，给了四个方向的相同的力，这样就会形成一种相对的均衡力量让其停留在中间位置了。</p><h4 id="75-refs和-nextTick"><a href="#75-refs和-nextTick" class="headerlink" title="75.$refs和$nextTick"></a>75.$refs和$nextTick</h4><p><strong>答案：$refs 获取DOM元素，操作DOM，如果ref绑定到组件上，可以获取当前绑定组件的实例</strong></p><p><strong>$refs使用场景: 1.整体校验，2.父组件调用子组件方法</strong></p><p>//    <h2 ref="语义化名字">.$refs 获取DOM元素</h2></p><p> mounted () {</p><p>  console.log(this.$refs)</p><p>  this.$refs.h2.style.color = ‘red’</p><p> }</p><p><strong>$nextTick 的作用：把回调函数延迟执行，等下次DOM更新完毕之后，再执行回调中的代码</strong> </p><p>好处是：能够保证回调中的代码，能操作到更新完毕后，最新的DOM元素</p><p>使用场景：canvas绘制头像二维码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">     <span class="hljs-built_in">this</span>.$nextTick(<span class="hljs-function">() =&gt;</span> &#123;<br>       QrCode.toCanvas(<span class="hljs-built_in">this</span>.$refs.cas, photoUrl)<br>     &#125;)<br><br><span class="hljs-attr">C</span>:\Users\Administrator\Desktop\后台系统练习\vue-admin-template\src\views\employees\index.vue<br><span class="hljs-comment">// 第166行代码</span><br></code></pre></td></tr></table></figure><h4 id="76-如何实现双飞翼（圣杯）布局？"><a href="#76-如何实现双飞翼（圣杯）布局？" class="headerlink" title="76.如何实现双飞翼（圣杯）布局？"></a>76.如何实现双飞翼（圣杯）布局？</h4><p>1、<strong>利用定位实现两侧固定中间自适应</strong> </p><p>1.1）父盒子设置左右 padding 值 </p><p>1.2）给左右盒子的 width 设置父盒子的 padding 值,然后分别定位到 padding 处.</p><p>1.3）中间盒子自适应</p><p>2、<strong>利用 flex 布局实现两侧固定中间自适应</strong> </p><p>2.1）父盒子设置 display:flex; </p><p>2.2）左右盒子设置固定宽高 </p><p>2.3）中间盒子设置 flex:1 ;</p><h4 id="77-父组件使用子组件调用子组件的方法"><a href="#77-父组件使用子组件调用子组件的方法" class="headerlink" title="77.父组件使用子组件调用子组件的方法"></a>77.父组件使用子组件调用子组件的方法</h4><p>父组件标签用ref：<Child ref="dianji" /></p><p>父组件 methods 下 用 this.$refs.dianji.子组件的方法名()           进行调用</p><p>this.$refs.arole.getUserRoles()</p><h4 id="78-子组件调用父组件使用调用父组件的方法"><a href="#78-子组件调用父组件使用调用父组件的方法" class="headerlink" title="78.子组件调用父组件使用调用父组件的方法"></a>78.子组件调用父组件使用调用父组件的方法</h4><p>this.$parent.getList()</p><p>在子组件里用<code>$emit</code>向父组件触发一个事件，父组件监听这个事件就行了，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 添加成功后刷新列表</span><br><span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&#x27;update-tree&#x27;</span>)<br><br></code></pre></td></tr></table></figure><p>教程：<a href="https://blog.csdn.net/zgrkaka/article/details/100528714">https://blog.csdn.net/zgrkaka/article/details/100528714</a></p><h4 id="79-渲染用户频道列表数据"><a href="#79-渲染用户频道列表数据" class="headerlink" title="79.渲染用户频道列表数据"></a>79.渲染用户频道列表数据</h4><p>1.封装接口（homeAPI.js）</p><ul><li>导入 import request from ‘../utils/request’</li></ul><p>2.获取API （homeAPI.js）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> 自定义接口名API = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br><br> <span class="hljs-keyword">return</span> request.get(<span class="hljs-string">&#x27;/v1_0/user/channels&#x27;</span>)<br><br>&#125;<br></code></pre></td></tr></table></figure><p>3.在需要的地方导入接口(home.vue)</p><p>import { getUserChannelsAPI } from ‘./api/homeApi’</p><p>4.vue文件中封装方法(methods)，调用接口</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> 方法名 () &#123;<br>  <span class="hljs-comment">// 调用api接口</span><br>  <span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">data</span>: res &#125; = <span class="hljs-keyword">await</span> 接口名()<br>  <span class="hljs-built_in">console</span>.log(res)<br>  <span class="hljs-comment">// 判断是否请求成功</span><br>  <span class="hljs-keyword">if</span> (res.message === <span class="hljs-string">&#x27;OK&#x27;</span>) &#123;<br>    <span class="hljs-built_in">this</span>.allChannel = res.data.channels<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.allChannel)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>5.判断是不是OK，是的话数据转存到vdata下自定义名字的空数组</p><p>6.给空数组 赋值，写法：this.空数组名 = res.data.channels  (等号右边的数据 去log或者接口文档找)</p><p>7.找到相关标签，使用v-for循环遍历出来 (v-for = 自己起的名 in 数组名 :key=”自己起的名.id”)</p><h4 id="80-axios拦截器（提升用户体验）"><a href="#80-axios拦截器（提升用户体验）" class="headerlink" title="80.axios拦截器（提升用户体验）"></a>80.axios拦截器（提升用户体验）</h4><p><strong>响应拦截器</strong>：函数1。处理的是成功状态（状态码2xx，3xx）的响应</p><p>​                   ：函数2。处理的是失败状态（状态码4xx，5xx）的响应</p><p>使用场景：账号密码错误， token的**<code>统一注入问题</code>**      来自：基础环境搭建</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 添加响应拦截器</span><br>axios.interceptors.response.use(<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>&#123;<br>    <span class="hljs-comment">// 在发送请求之前做些什么</span><br>    <span class="hljs-keyword">return</span> response;<br>  &#125;, <br>    <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>&#123;<br>    <span class="hljs-comment">// 对请求错误做些什么</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(error);<br>  &#125;);<br></code></pre></td></tr></table></figure><p><img src="https://wushuo1031.oss-cn-beijing.aliyuncs.com/img/image-20210911112801623.png" alt="image-20210911112801623"></p><p><strong>请求拦截器</strong>：作用：可以向header中统一添加token</p><p><strong>发请求的过程：</strong>axios发请求，经过请求拦截器，发送到服务器</p><p>​                           服务器接收到数据后，经过相应拦截器，返回给我们</p><h4 id="81-防抖和节流"><a href="#81-防抖和节流" class="headerlink" title="81.防抖和节流"></a>81.防抖和节流</h4><p>防抖seTtimeout：频繁的触发某个操作时，仅触发最后一次</p><p>节流：单位时间内，重复操作只会触发一次</p><p>这俩的区别：</p><p>防抖函数控制函数在一定时间内的执行次数。防抖意味着 N 秒内函数只会被执行一次（最后一次），如果 N 秒内再次被触发，则重新计算延迟时间；</p><p>节流函数规定一个单位时间，在这个单位时间内最多只能触发一次函数执行，如果这个单位时间内多次触发函数，只能有一次生效。（输入框的模糊查询）</p><h4 id="82-箭头函数和普通函数的区别"><a href="#82-箭头函数和普通函数的区别" class="headerlink" title="82.箭头函数和普通函数的区别"></a>82.箭头函数和普通函数的区别</h4><ul><li>箭头函数语法简单，清晰；</li><li>箭头函数没有prototype，所以本身没this；</li><li>箭头函数不会创建自己的this；</li><li>Call/apply/bind无法改变this指向；</li><li>不能作为构造函数使用；</li></ul><h4 id="83-构造函数和普通函数的区别"><a href="#83-构造函数和普通函数的区别" class="headerlink" title="83.构造函数和普通函数的区别"></a>83.构造函数和普通函数的区别</h4><ul><li>构造用new调用；</li><li>构造内部可以使用this，普通不建议，会指向window；</li><li>构造没有return返回值</li><li>构造首字母大写。</li></ul><h4 id="84-你见过的浏览器内核有哪些？"><a href="#84-你见过的浏览器内核有哪些？" class="headerlink" title="84.你见过的浏览器内核有哪些？"></a>84.你见过的浏览器内核有哪些？</h4><ul><li>IE Trident IE、猎豹安全、360极速浏览器、百度浏览器</li><li>firefox Gecko 可惜这几年已经没落了，打开速度慢、升级频繁、猪一样的队友flash、神一样的对手chrome。</li><li>Safari webkit 从Safari推出之时起，它的渲染引擎就是Webkit，一提到 webkit，首先想到的便是 chrome，可以说，chrome 将 Webkit内核 深入人心，殊不知，Webkit 的鼻祖其实是 Safari。</li><li>chrome Chromium/Blink 在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。Blink 其实是 WebKit 的分支。大部分国产浏览器最新版都采用Blink内核。二次开发</li><li>Opera blink 现在跟随chrome用blink内核。</li></ul><h4 id="85-内存泄漏的解决方法"><a href="#85-内存泄漏的解决方法" class="headerlink" title="85.内存泄漏的解决方法"></a>85.内存泄漏的解决方法</h4><p>可以用<strong>null</strong>来释放内存，比如是闭包，可以讲闭包的这个函数赋值为null</p><h4 id="86-webpack"><a href="#86-webpack" class="headerlink" title="86.webpack"></a>86.webpack</h4><p><img src="https://wushuo1031.oss-cn-beijing.aliyuncs.com/img/image-20210913235651852.png" alt="image-20210913235651852"></p><h5 id="X-小程序"><a href="#X-小程序" class="headerlink" title="X.小程序"></a><strong>X.小程序</strong></h5><p>目录结构：pages-存放页面的文件夹</p><p>utils文件夹 - 工具函数文件夹（例如日期格式）</p><p>app.js - 小程序的入口文件 - App函数创建小程序的实例对象</p><p><strong>app.json - 全局配置文件</strong>：</p><p>apps.wxss - 全局样式文件</p><p>project.config.json - 项目配置文件 - checkSiteMap:false, 取消log警告</p><p>sitemap.json - 小程序页面被搜索的规则</p><p>我叫武昌硕 来自于河北石家庄 在前端行业工作两年了                                                                                     18年出来实习，直接签了合同了</p><p>我之前呢 在石家庄工作 上家公司是在石家庄智凌科技有限公司 担任的前端开发工作 技术栈主要使用Vue全家桶</p><p>在之前的工作当中 做过很多的项目 但是在简历里写的 是我最近做过的项目 比如这个HR后台管理系统 他里边的一些数据的渲染 包括我们的Vuex的存储 登陆功能 权限管理这一块 还有云储存这一块呢 都是有的 像这个后台管理系统 是属于一个各个企业都会用到的后台系统  在项目中遇到最大的问题 就是 退出登陆后 因为路由有缓存 造成下一个登陆人 可以访问上一个登陆人的权限页面</p><p>这个问题呢 我解决的思路是在退出登陆时 调用重置路由的方法 并重置vuex的数据来解决的</p><p>基本我的个人介绍先这么多 ，面试官有什么想问的可以提出来</p><p>公司 1个产品 1个项目经理 2个前端 4个后端  1个测试</p><p>做过后台管理项目，论坛，移动APP项目</p><p>产品给出需求文档，产品原型开会</p><h4 id="87-Vue创建项目步骤"><a href="#87-Vue创建项目步骤" class="headerlink" title="87.Vue创建项目步骤"></a>87.Vue创建项目步骤</h4><ol><li>最后一个 自定义</li><li> 勾选 路由 CSS预处理器 Vuex</li><li>2.x</li><li>路由模式 N</li><li>样式选择 LESS</li><li>ESLINT 第三个</li><li>第一个 save</li><li>继续回车</li><li>不保存 N</li></ol><h4 id="88-饿了么UI细节"><a href="#88-饿了么UI细节" class="headerlink" title="88.饿了么UI细节"></a>88.饿了么UI细节</h4><p><strong>layout布局组件</strong></p><ul><li>el-row的  :gutter=”10” 代表的是行间距</li><li>el-row 加 type=”flex” justify=”center” 可以居中</li></ul><p><strong>Table表格组件</strong></p><ul><li><p>el-table的 :data 代表的是数据源</p></li><li><p>el-table-column列组件 列数据由prop=””   绑定</p></li><li><p>渲染自定义内容需要使用作用域插槽</p></li><li><p>格式化性别的方法</p></li></ul><p>结构代码区域：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;el-table-column label=&quot;性别&quot;&gt;<br>  &lt;template #default=&quot;&#123; row &#125;&quot;&gt;<br>    &lt;p&gt;&#123;&#123; geshihuasix(row.six) &#125;&#125;&lt;/p&gt;<br>  &lt;/template&gt;<br>&lt;/el-table-column&gt;<br></code></pre></td></tr></table></figure><p>功能代码区域：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vue">methods: &#123;<br>  // 格式化性别<br>  // type 1代表男 2代表女<br>  geshihuasix (type) &#123;<br>    const maps = &#123; 1: &#x27;男&#x27;, 2: &#x27;女&#x27; &#125;<br>    return maps[type]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Page分页组件</strong></p><ul><li><p>一般搭配Table组件进行使用</p></li><li><p>background用来控制小黑框的</p></li><li><p>page-size代表每一页显示多少条数据</p></li><li><p>:total 列表数据的总数</p></li><li><p>自带一个点击事件 @current-change=”pageChange” 可以获取当前页码</p></li><li><p>结构代码区域</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;el-pagination<br>  background<br>  layout=&quot;prev, pager, next&quot;<br>  :page-size=&quot;10&quot;<br>  :total=&quot;1000&quot;<br>  @current-change=&quot;pageChange&quot;<br>&gt;<br>&lt;/el-pagination&gt;<br></code></pre></td></tr></table></figure></li><li><p>功能结构部分</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">pageChange (niubi) &#123;<br>  <span class="hljs-built_in">console</span>.log(niubi)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Form表单</strong></p></li><li><p>ref代表 组件实例对象</p></li><li><p>表单校验时需要在相应的标签上写prop</p></li><li><p>rules是一个对象，里边的校验规则是数组</p></li><li><p>坑：自定义函数校验规则的时候需要在 复制的 正则规则前 加!</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vuex实现兄弟组件通信</title>
    <link href="/2021/09/10/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8vuex%E5%AE%9E%E7%8E%B0%E5%85%84%E5%BC%9F%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/"/>
    <url>/2021/09/10/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8vuex%E5%AE%9E%E7%8E%B0%E5%85%84%E5%BC%9F%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h3><p>vuex主要是是做数据交互，父子组件传值可以很容易办到，但是兄弟组件间传值，需要先将值传给父组件，再传给子组件，异常麻烦。</p><p>下面这篇文章就来给大家介绍下vuex兄弟组件通信的方法，下面话不多说了，来一起看看详细的介绍吧</p><h3 id="1-核心想法"><a href="#1-核心想法" class="headerlink" title="1. 核心想法"></a><strong>1. 核心想法</strong></h3><p>使用vuex进行兄弟组件通信的核心思路就是将vuex作为一个store(vuex被设计的原因之一)，将每个子组件的数据都存放进去，每个子组件都从vuex里获取数据，其实就是一句话——把vuex作为一个桥</p><h3 id="2-具体代码"><a href="#2-具体代码" class="headerlink" title="2. 具体代码"></a><strong>2. 具体代码</strong></h3><p>父组件App.vue</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br> &lt;div id=&quot;app&quot;&gt;<br> &lt;ChildA/&gt;<br> &lt;ChildB/&gt;<br> &lt;/div&gt;<br>&lt;/template&gt;<br> <br>&lt;script&gt;<br> import ChildA from &#x27;./components/ChildA&#x27; // 导入A组件<br> import ChildB from &#x27;./components/ChildB&#x27; // 导入B组件<br> <br> export default &#123;<br> name: &#x27;App&#x27;,<br> components: &#123;ChildA, ChildB&#125; // 注册A、B组件<br> &#125;<br>&lt;/script&gt;<br> <br>&lt;style&gt;<br> #app &#123;<br> font-family: &#x27;Avenir&#x27;, Helvetica, Arial, sans-serif;<br> -webkit-font-smoothing: antialiased;<br> -moz-osx-font-smoothing: grayscale;<br> text-align: center;<br> color: #2c3e50;<br> margin-top: 60px;<br> &#125;<br> <br> div &#123;<br> margin: 10px;<br> &#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>子组件ChildA</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br> &lt;div id=&quot;childA&quot;&gt;<br> &lt;h1&gt;我是A组件&lt;/h1&gt;<br> &lt;button @click=&quot;transform&quot;&gt;点我让B组件接收到数据&lt;/button&gt;<br> &lt;p&gt;因为你点了B，所以我的信息发生了变化：&#123;&#123;BMessage&#125;&#125;&lt;/p&gt;<br> &lt;/div&gt;<br>&lt;/template&gt;<br> <br>&lt;script&gt;<br> export default &#123;<br> data() &#123;<br> return &#123;<br> AMessage: &#x27;Hello，B组件，我是A组件&#x27;<br> &#125;<br> &#125;,<br> computed: &#123;<br> BMessage() &#123;<br> // 这里存储从store里获取的B组件的数据<br> return this.$store.state.BMsg<br> &#125;<br> &#125;,<br> methods: &#123;<br> transform() &#123;<br> // 触发receiveAMsg，将A组件的数据存放到store里去<br> this.$store.commit(&#x27;receiveAMsg&#x27;, &#123;<br>  AMsg: this.AMessage<br> &#125;)<br> &#125;<br> &#125;<br> &#125;<br>&lt;/script&gt;<br> <br>&lt;style&gt;<br> div#childA &#123;<br> border: 1px solid black;<br> &#125;<br>&lt;/style&gt;<br><br></code></pre></td></tr></table></figure><p>子组件ChildB</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br> &lt;div id=&quot;childB&quot;&gt;<br> &lt;h1&gt;我是B组件&lt;/h1&gt;<br> &lt;button @click=&quot;transform&quot;&gt;点我让A组件接收到数据&lt;/button&gt;<br> &lt;p&gt;因为你点了A，所以我的信息发生了变化：&#123;&#123;AMessage&#125;&#125;&lt;/p&gt;<br> &lt;/div&gt;<br>&lt;/template&gt;<br> <br>&lt;script&gt;<br> export default &#123;<br> data() &#123;<br> return &#123;<br> BMessage: &#x27;Hello，A组件，我是B组件&#x27;<br> &#125;<br> &#125;,<br> computed: &#123;<br> AMessage() &#123;<br> // 这里存储从store里获取的A组件的数据<br> return this.$store.state.AMsg<br> &#125;<br> &#125;,<br> methods: &#123;<br> transform() &#123;<br> // 触发receiveBMsg，将B组件的数据存放到store里去<br> this.$store.commit(&#x27;receiveBMsg&#x27;, &#123;<br>  BMsg: this.BMessage<br> &#125;)<br> &#125;<br> &#125;<br> &#125;<br>&lt;/script&gt;<br> <br>&lt;style&gt;<br> div#childB &#123;<br> border: 1px solid green;<br> &#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>vuex模块store.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> Vuex <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br> <br>Vue.use(Vuex)<br> <br><span class="hljs-keyword">const</span> state = &#123;<br> <span class="hljs-comment">// 初始化A和B组件的数据，等待获取</span><br> <span class="hljs-attr">AMsg</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br> <span class="hljs-attr">BMsg</span>: <span class="hljs-string">&#x27;&#x27;</span><br>&#125;<br> <br><span class="hljs-keyword">const</span> mutations = &#123;<br> <span class="hljs-function"><span class="hljs-title">receiveAMsg</span>(<span class="hljs-params">state, payload</span>)</span> &#123;<br> <span class="hljs-comment">// 将A组件的数据存放于state</span><br> state.AMsg = payload.AMsg<br> &#125;,<br> <span class="hljs-function"><span class="hljs-title">receiveBMsg</span>(<span class="hljs-params">state, payload</span>)</span> &#123;<br> <span class="hljs-comment">// 将B组件的数据存放于state</span><br> state.BMsg = payload.BMsg<br> &#125;<br>&#125;<br> <br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> Vuex.Store(&#123;<br> state,<br> mutations<br>&#125;)<br></code></pre></td></tr></table></figure><p>我把所有的代码+注释都放在github了，<a href="https://github.com/bluesbonewong/vuex-brother-component-tutorial/tree/master/vuex-bro-tutorial">源码链接</a>，<a href="https://bluesbonewong.github.io/vuex-brother-component-tutorial/vuex-bro-tutorial/dist/index.html">预览链接 </a></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue之图片懒加载</title>
    <link href="/2021/09/01/%E6%87%92%E5%8A%A0%E8%BD%BD/"/>
    <url>/2021/09/01/%E6%87%92%E5%8A%A0%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h3 id="一-vue-lazyload插件："><a href="#一-vue-lazyload插件：" class="headerlink" title="一. vue lazyload插件："></a><strong>一. vue lazyload插件：</strong></h3><p>插件地址：<a href="https://github.com/hilongjw/vue-lazyload">https://github.com/hilongjw/vue-lazyload</a></p><h3 id="二-简单使用实例："><a href="#二-简单使用实例：" class="headerlink" title="二. 简单使用实例："></a><strong>二. 简单使用实例：</strong></h3><p>其实这个插件做简单使用的话是很简单的，看官方文档的话反而被误导了，可以先按下边的实例实现简单引用，后边再根据开发文档做扩展。直接对代码开始</p><ol><li>安装插件：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apl">npm install vue-lazyload --save-dev<br></code></pre></td></tr></table></figure><ol start="2"><li>main.js引入插件：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> VueLazyLoad <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-lazyload&#x27;</span><br><br>Vue.use(VueLazyLoad,&#123;<br>    <span class="hljs-attr">loading</span>:<span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;common/image/default.png&#x27;</span>)  <span class="hljs-comment">//这个就是你本地图片的地址</span><br>&#125;)<br></code></pre></td></tr></table></figure><ol start="3"><li>vue文件中将需要懒加载的图片绑定 v-bind:src 修改为 v-lazy </li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">:src</span>=<span class="hljs-string">&quot;item.imgurl&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 60px;height: 60px;&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">v-lazy</span>=<span class="hljs-string">&quot;item.imgurl&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 60px;height: 60px;&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><h3 id="三-功能扩展："><a href="#三-功能扩展：" class="headerlink" title="三.功能扩展："></a><strong>三.功能扩展：</strong></h3><p>图片懒加载的简单效果已经实现了，然后就可以按这开发文档的api进行扩展了：</p><table><thead><tr><th>key</th><th>description</th><th>default</th><th>options</th></tr></thead><tbody><tr><td><code>preLoad</code></td><td>proportion of pre-loading height（预加载高度比例）</td><td><code>1.3</code></td><td><code>Number</code></td></tr><tr><td><code>error</code></td><td>src of the image upon load fail（图片路径错误时加载图片）</td><td><code>&#39;data-src&#39;</code></td><td><code>String</code></td></tr><tr><td><code>loading</code></td><td>src of the image while loading（预加载图片）</td><td><code>&#39;data-src&#39;</code></td><td><code>String</code></td></tr><tr><td><code>attempt</code></td><td>attempts count（尝试加载图片数量）</td><td><code>3</code></td><td><code>Number</code></td></tr><tr><td><code>listenEvents</code></td><td>events that you want vue listen for（想要监听的vue事件）默认[‘scroll’]可以省略，当插件跟页面中的动画或过渡等事件有冲突是，可以尝试其他选项</td><td><code>[&#39;scroll&#39;（默认）,``&#39;wheel&#39;,``&#39;mousewheel&#39;,``&#39;resize&#39;,``&#39;animationend&#39;,``&#39;transitionend&#39;,``&#39;touchmove&#39;]</code></td><td><a href="https://www.npmjs.com/package/vue-lazyload#desired-listen-events">Desired Listen Events</a></td></tr><tr><td><code>adapter</code></td><td>dynamically modify the attribute of element（动态修改元素属性）</td><td><code>&#123; &#125;</code></td><td><a href="https://www.npmjs.com/package/vue-lazyload#element-adapter">Element Adapter</a></td></tr><tr><td><code>filter</code></td><td>the image’s listener filter（动态修改图片地址路径）</td><td><code>&#123; &#125;</code></td><td><a href="https://www.npmjs.com/package/vue-lazyload#image-listener-filter">Image listener filter</a></td></tr><tr><td><code>lazyComponent</code></td><td>lazyload component</td><td><code>false</code></td><td><a href="https://www.npmjs.com/package/vue-lazyload#lazy-component">Lazy Component</a></td></tr><tr><td><code>dispatchEvent</code></td><td>trigger the dom event</td><td><code>false</code></td><td><code>Boolean</code></td></tr><tr><td><code>throttleWait</code></td><td>throttle wait</td><td><code>200</code></td><td><code>Number</code></td></tr><tr><td><code>observer</code></td><td>use IntersectionObserver</td><td><code>false</code></td><td><code>Boolean</code></td></tr><tr><td><code>observerOptions</code></td><td>IntersectionObserver options</td><td>{ rootMargin: ‘0px’, threshold: 0.1 }</td><td><a href="https://www.npmjs.com/package/vue-lazyload#intersectionobserver">IntersectionObserver</a></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>人资总结</title>
    <link href="/2021/08/31/%E4%BA%BA%E8%B5%84%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    <url>/2021/08/31/%E4%BA%BA%E8%B5%84%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="01-人资项目总结"><a href="#01-人资项目总结" class="headerlink" title="01-人资项目总结"></a>01-人资项目总结</h1><h3 id="01-登陆模块"><a href="#01-登陆模块" class="headerlink" title="01-登陆模块"></a>01-登陆模块</h3><h4 id="1-如何实现"><a href="#1-如何实现" class="headerlink" title="1. 如何实现"></a>1. 如何实现</h4><p>​    首先使用 vue-element-admin 的 login 登陆模块, 来进行二开, 使用 eml 提供的 表单验证功能进行表单校验, 封装登陆接口, 在 vuex 中定义 user 模块, 存储 token 信息, 在 actions 中定义登陆方法调用接口, 获取token, 并存在 state 中. 在 表单验证通过后, dispatch 调用登陆方法, 存储token, 并使用 localstorage 本地持久化存储. 之后在请求拦截器中 统一注入. 后续完成页面的访问控制, (在路由前置守卫中判断是否有 token, 然后在判断是否为登录页, 若是则跳转主页; 若不是, 则放行. 若没有 token, 则判断是否为白名单页(/login, /404), 是则放行, 不是则跳转登录).与 token 失效处理 ( 在响应拦截器中错误回调处, 进行 状态码 401 的判断, 如果401 则清除token, 和调回登录页, 并抛出错误信息 )</p><h4 id="2-技术难点"><a href="#2-技术难点" class="headerlink" title="2.技术难点"></a>2.技术难点</h4><ol><li>处理某些页面多个请求多次401重复跳转问题，造成重新登录后不能正确跳转到上次访问页面问题<br>if (router.currentRoute.path === ‘/login’) return</li></ol><h3 id="02-组织架构"><a href="#02-组织架构" class="headerlink" title="02-组织架构"></a>02-组织架构</h3><p>​    该模块是将后台返回的数据, 以树状图的形式展示出来. 主要使用了 elm 的 el-card,嵌套 el-tree 实现. 我们需要根据后台返回的数据, 来定义一个公共的格式化数据的方法: 定义一个空数组, 存放处理的数据, 循环返回的数据,定义一个 <em>部门 ID 作为 key, 部门数据为值</em> 的关系. 继续遍历返回的数据, 将 pid 作为键, 在 map 中查找, 并返回. 如果返回 undefined 则 为顶层部门, 直接 push到 空数组中, 如果有值 则为子部门, push 到 空数组中的 子目录下.  之后在组建中调用方法渲染到模板即可.</p><p>​    之后完成了 新增, 修改, 删除, 的功能. 点击新增 / 编辑 进入 el-dialog 弹层, 弹层做简单的校验,根据表单是否有id 判断是 新增还是 修改的操作, 调用接口完成相应功能. </p><p>​    编辑回填功能: 在父组件中 使用 $refs 获取 子组件中的方法, 调用回填</p><h3 id="03-权限管理"><a href="#03-权限管理" class="headerlink" title="03-权限管理"></a>03-权限管理</h3><p>​    权限管理, 使用了 RBAC 权限设计理念, 即:  1. 给用户分配角色  2. 给角色分配权限点 , 他的出现 解决了:  1. 权限点直接赋予某个账号   2. 相同的权限需要重复赋予  他的优点: 1. 更加高效  2. 复用: 一个角色可以分配给多个用户</p><p>​    权限管理即为:控制动态路由实现按照角色登录获取到对应的可访问的页面, 与根据角色的不同设置不同的操作按钮权限</p><p>​    <strong>首先实现控制动态路由:</strong> 1. 在 路由控制的页面中, 只留下 静态路由, 动态路由, 根据权限点的数据控制 2. 获取登录人的权限点数据, 首先在 vuex user模块下 将菜单的权限点数据以 return 形式返回,  并在路由前置导航守卫中获取  3. 将 动态路由导出 并 按需导入到 控制路由的 permission 下,  使用 array.filter + includes 来, 根据每一个动态路由的第一个子路由的名字, 来过滤当前角色权限路由点, 4. 使用 路由的方法 router.addRoutes 添加动态路由</p><p>​    <strong>再实现控制操作按钮:</strong> 1. 使用mixin或原型定义全局公共的权限点检查方法, 定义检查页面下的功能点 方法, 传入 权限点 point, 通过 返回一个 includes 方法, 来判断 该权限点 是否在, 权限点数组中.  2. 在全局中导入 mixin 方法 使用 Vue.mixin() 全局混入  3. 使用方法  到具体需要控制的页面，在页面的功能按钮上，使用v-if=”调用混入检测方法(‘传入代表这个功能的权限点标识字符串’)”   检查到返回true显示按钮，相反不显示</p><h4 id="问题处理"><a href="#问题处理" class="headerlink" title="问题处理:"></a>问题处理:</h4><p><strong>1. 刷新页面后, 路由出现 404?</strong></p><p>将 router/index 下的 404 路由 删掉, 之后合并到动态路由的后边</p><p><strong>2. 动态加完, 路由菜单不显示?</strong></p><p>this.$router.options.routers 只能获取静态路由,不是响应式的, 所以里面有了数据也不会反应到视图中, 所以需要全局响应式的数据 —–vuex</p><p>新建委会公共布局左侧菜单数据 vuex 模块, 并在权限控制下, commit 调用 存储菜单数据的 mutation, 并传入 可访问的动态路由. 之后在 sidebar 下 改造 , 调用 vuex 中存菜单的 store 来渲染菜单</p><p><strong>3. 在退出登录后, 因为路由有缓存, 造成下一个登录人可以访问上一个登录人的权限页面</strong>?</p><p>在 退出登录/ 401时 调用 重置路由的方法, 并重置菜单 vuex 数据 (会重新复用工程函数, 复用其创造一个新的实例)</p><p><strong>4. 退出登录时重置用户数据，会响应式刷新，执行checkPermission获取数据异常</strong></p><p>解决方法: 使用 ES10的  ‘ ? ‘   或 if判断, 如果有 roles 在 return<br>return userInfo.roles?.points.includes(point) </p><h3 id="04-员工管理"><a href="#04-员工管理" class="headerlink" title="04-员工管理"></a>04-员工管理</h3><p>​    该模块除了列表的渲染, 还有导入导出, 新增, 查看, 删除员工, 分配角色等功能</p><p>​    导入功能实现; 使用的是基于vue-element-admin中的现成方案 , 依赖 第三方xlsx包, 点击<code>excel导入</code>按钮，弹出导入功能的页面, 选择准备好要导入的excel表格文件，.经过数据格式化以后, 传入接口 批量导入</p><p>​    导出功能实现; 点击导出excel 功能, 点击导出 excel 按钮后 导出一份 excel 文件. 导出功能也是基于vue-element-admin中的现成方案, 并下载相关依赖包 xlsx, file-saver,  script-loader. 将数据处理成二维数组, 传入导出的方法后, 调用导出方法, 即可完成功能</p><p>​    查看功能: 点击查看后, 通过路由跳转至详情页面,利用 el-tab,组件,可以切换 多个标签页. 其中封装了用户名, 部门数据, 员工头像等修改内容</p><h3 id="00-另外"><a href="#00-另外" class="headerlink" title="00-另外"></a>00-另外</h3><h4 id="1-Vue-Cli配置跨域请求"><a href="#1-Vue-Cli配置跨域请求" class="headerlink" title="1. Vue-Cli配置跨域请求"></a>1. Vue-Cli配置跨域请求</h4><p>在**<code>vue.config.js</code>**, 中的 DevServe 对象中的配置 跨域请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">proxy: &#123;<br>  <span class="hljs-comment">// 当我们的本地的请求 有/api的时候，就会代理我们的请求地址向另外一个服务器发出请求</span><br>  <span class="hljs-string">&#x27;/api&#x27;</span>: &#123;<br>    <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://www.itcbc.com:3000&#x27;</span>, <span class="hljs-comment">// 跨域请求的地址</span><br>    <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// 只有这个值为true的情况下 才表示开启跨域(默认true)</span><br>    <span class="hljs-comment">// 路径重写</span><br>    <span class="hljs-comment">// 如果 真实后台没有api前缀情况 则 需要加以下属性来将 /api 重置为空</span><br>    <span class="hljs-comment">// pathRewrite: &#123;</span><br>    <span class="hljs-comment">//   &#x27;^/api&#x27;: &#x27;&#x27;</span><br>    <span class="hljs-comment">// &#125;</span><br>  &#125;<br>&#125;<br>之后 修改 baseURL 中的地址, 改为 /api<br></code></pre></td></tr></table></figure><h4 id="2-elm-组件库-分页删除-bug"><a href="#2-elm-组件库-分页删除-bug" class="headerlink" title="2. elm 组件库 分页删除 bug"></a>2. elm 组件库 分页删除 bug</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 组件库bug: 处理最后一页数据全部删除完成后列表页码正确, 但数据显示错误问题 (刷新列表使用的是上次的页码)</span><br><span class="hljs-comment"> * 解决: 解决页码错误问题, 使用正确页码发送请求</span><br><span class="hljs-comment"> * 例子: 总共 8 页数据, 把第 8 页数据全删除后还剩 7 页</span><br><span class="hljs-comment"> * 步骤: 1. 重新计算页码 =&gt; 总条数 / 每页条数 = 页码</span><br><span class="hljs-comment"> *      2. 和之前的页码做对比 =&gt; 条件: 之前的页码 &gt; 重新计算页码 =&gt; 修正页码</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 纠正页码错误: 因为上边已经删除了一条数据 所以总条数要减 1</span><br><span class="hljs-keyword">const</span> newPage = <span class="hljs-built_in">Math</span>.ceil((<span class="hljs-built_in">this</span>.total - <span class="hljs-number">1</span>) / <span class="hljs-built_in">this</span>.params.size)<br><span class="hljs-comment">// 页码 &gt; 0 ( 默认页码最小是1 )</span><br><span class="hljs-keyword">if</span> (newPage &gt; <span class="hljs-number">0</span>) &#123;<br>  <span class="hljs-comment">// 纠正页码</span><br>  <span class="hljs-built_in">this</span>.params.page = <span class="hljs-built_in">this</span>.params.page &gt; newPage ? newPage : <span class="hljs-built_in">this</span>.params.page<br>&#125;<br><span class="hljs-built_in">this</span>.getList()<br></code></pre></td></tr></table></figure><h4 id="3-自定义指令-处理异常图片"><a href="#3-自定义指令-处理异常图片" class="headerlink" title="3. 自定义指令-处理异常图片"></a>3. 自定义指令-处理异常图片</h4><p>当图片显示破图的时候：通过自定义指令解决  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. 在 src/directives/index.js下注册自定义指令</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> imgError = &#123;<br>  inserted (dom, options) &#123;<br>    <span class="hljs-built_in">console</span>.log(dom, options)<br>    <span class="hljs-comment">// 注册图片加载失败事件 onerror</span><br>    dom.onerror = <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-comment">// 显示默认图片</span><br>      dom.src = options.value<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 2. 在main.js中完成自定义指令全局注册</span><br><span class="hljs-built_in">Object</span>.keys(directives).forEach(<span class="hljs-function"><span class="hljs-params">dname</span> =&gt;</span> &#123;<br>  Vue.directive(dname, directives[dname])<br>&#125;)<br><span class="hljs-comment">// 3. 指令注册成功就可以在navbar.vue中直接使用  </span><br>&lt;img v-imgError=<span class="hljs-string">&quot;defaultTx&quot;</span> :src=<span class="hljs-string">&quot;avatar&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;user-avatar&quot;</span> /&gt;<br>data () &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-comment">// 默认头像 ( 图片加载失败显示该图片 ) ~~使用了commonjs的导入语法</span><br>      <span class="hljs-attr">defaultTx</span>: <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;@/assets/common/bigUserHeader.png&#x27;</span>)<br>    &#125;  &#125;,<br></code></pre></td></tr></table></figure><h4 id="4-饿了么组件库使用总结"><a href="#4-饿了么组件库使用总结" class="headerlink" title="4. 饿了么组件库使用总结:"></a>4. 饿了么组件库使用总结:</h4><p>1.安装</p><p>2.在main.js中导入 （两个）// 引入组件库的功能和样式</p><p>import ElementUI from ‘element-ui’  ;    import ‘element-ui/lib/theme-chalk/index.css’</p><p>3.注册    Vue.use(ElementUI)</p><h4 id="5-组件库使用的四要素："><a href="#5-组件库使用的四要素：" class="headerlink" title="5. 组件库使用的四要素："></a>5. 组件库使用的四要素：</h4><p>1.prop  （父传子）</p><p>2.自定义事件 （子传父）</p><p>3.插槽 （自定义内容） </p><p>4.命令式调用方法  （通过ref获取组件实例上的方法）</p><p>this.$refs.form.validate()全局校验</p><h1 id="02-项目优化"><a href="#02-项目优化" class="headerlink" title="02-项目优化"></a>02-项目优化</h1><h4 id="组件数据懒加载"><a href="#组件数据懒加载" class="headerlink" title="组件数据懒加载:"></a>组件数据懒加载:</h4><p>组件数据懒加载就是组件只有正式进入到视口中，才发起组件内部的ajax请求，否则不请求数据</p><p>如何判断组件进入视口：</p><p>使用@vueuse/core 中的 useIntersectionObserver 来实现监听组件进入可视区域行为，需要配合vue3.0的组合API的方式才能实现</p><p>引入监听是否进入接口，import { useIntersectionObserver } from ‘@vueuse/core’</p><p><strong>通过ref属性获取组件实例</strong>，然后通过判断isIntersecting 是否进入可视区域，如果进入就停止监听放置重复调用，发起请求</p><h4 id="图片懒加载："><a href="#图片懒加载：" class="headerlink" title="图片懒加载："></a>图片懒加载：</h4><p>基于 Vant 的 lazyload 懒加载，可以轻松实现列表中 图片的懒加载效果</p><h4 id="路由懒加载："><a href="#路由懒加载：" class="headerlink" title="路由懒加载："></a>路由懒加载：</h4><p>​    当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了</p><ol><li>安装babel插件，修改项目根目录下的babel.config.js配置文件，新增plugins节点，实现路由组件按需导入的babel插件，然后再router.index.js中基于 const Foo = () =&gt; import(‘./Foo.vue’)语法，改造每个路由组件的导入方式</li></ol><h4 id="cdn文件配置（cdn加速）"><a href="#cdn文件配置（cdn加速）" class="headerlink" title="cdn文件配置（cdn加速）:"></a>cdn文件配置（cdn加速）:</h4><p>就是把大文件通过cdn方式引入（cdn加速），把排除在外的包通过cdn方式引入</p><p>Webpack / vue.config.js 配置 externals 配置项</p><p>减少应用打包出来的包体积;  加快静态资源的访问;  利用浏览器缓存，不会变动的文件长期缓存</p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前端经典面试题汇总</title>
    <link href="/2021/07/14/%E5%89%8D%E7%AB%AF%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <url>/2021/07/14/%E5%89%8D%E7%AB%AF%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h3 id="H5移动web"><a href="#H5移动web" class="headerlink" title="H5移动web"></a>H5移动web</h3><h3 id="1、简述弹性盒子flex布局及rem布局"><a href="#1、简述弹性盒子flex布局及rem布局" class="headerlink" title="1、简述弹性盒子flex布局及rem布局"></a><strong><a href="https://www.cnblogs.com/qcloud1001/p/9848619.html">1、简述弹性盒子flex布局及rem布局</a></strong></h3><ul><li><strong>flex布局方式</strong><ul><li>采用flex布局的元素,成为flex为容器,所有的子元素,都包含在容器内,容器存在两个默认的轴<ul><li>水平主轴<ul><li>主轴的开始位置(与边框的交叉点)叫做<code>main start</code>结束位置叫做<code>main end</code></li></ul></li><li>垂直交叉轴<ul><li>交叉轴的起始位置叫做<code>cross start</code>结束位置叫做<code>cross end</code>; </li></ul></li></ul></li><li>常用属性<ul><li><strong>flex-direction(决定主轴的排列方向)</strong><ul><li><code>row</code>（默认值）：主轴为水平方向，起点在左端。</li><li><code>row-reverse</code>：主轴为水平方向，起点在右端。</li><li><code>column</code>：主轴为垂直方向，起点在上沿。</li><li><code>column-reverse</code>：主轴为垂直方向，起点在下沿。</li></ul></li><li><strong>flex-wrap(默认都在一行显示,该属性课实现换行排列)</strong><ul><li><code>nowrap</code>(默认值): 不换行</li><li><code>wrap</code>：换行，第一行在上方</li><li><code>wrap-reverse</code>：换行，第一行在下方</li></ul></li><li><strong>flex-flow</strong><ul><li><code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code>。</li></ul></li><li><strong>justify-content(定义了项目在主轴上的对齐方式)</strong><ul><li><code>flex-start</code>（默认值）：左对齐</li><li><code>flex-end</code>：右对齐</li><li><code>center</code>： 居中</li><li><code>space-between</code>：两端对齐，项目之间的间隔都相等。</li><li><code>space-around</code>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li></ul></li><li><strong>align-items(定义项目在交叉轴上如何对齐)</strong><ul><li><code>flex-start</code>：交叉轴的起点对齐。</li><li><code>flex-end</code>：交叉轴的终点对齐。</li><li><code>center</code>：交叉轴的中点对齐。</li><li><code>baseline</code>: 项目的第一行文字的基线对齐。</li><li><code>stretch</code>（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li></ul></li><li><strong>align-content(定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用)</strong><ul><li><code>flex-start</code>：与交叉轴的起点对齐。</li><li><code>flex-end</code>：与交叉轴的终点对齐。</li><li><code>center</code>：与交叉轴的中点对齐。</li><li><code>space-between</code>：与交叉轴两端对齐，轴线之间的间隔平均分布</li><li><code>space-around</code>：每根轴线两侧的间隔都相等，所以，轴线之间的间隔比轴线与边框的间隔大一倍</li><li><code>stretch</code>（默认值）：轴线占满整个交叉轴</li></ul></li></ul></li></ul></li><li><strong>rem布局方式</strong><ul><li><strong>rem是什么?</strong><ul><li>rem（font size of the root element）是指相对于根元素的字体大小的单位，简单的说它就是一个相对单位,看到rem大家一定会想起em单位，em（font size of the element）是指相对于父元素的字体大小的单位,它们之间其实很相似，只不过rem计算的规则是依赖根元素,em是依赖父元素计算</li></ul></li><li><strong>rem布局</strong><ul><li>原理是，先按定高宽设计出来页面，然后转换为rem单位，配合js查询屏幕大小来改变html的font-size，最终做出所谓的完美自适应</li></ul></li><li><strong>rem使用场景</strong><ul><li>rem+js是宽度自适应，无法做到高度自适应，所以那些对高度要求很高的rem+js无法实现,改变浏览器宽度，你会发现，页面所有元素的高宽都等比例缩放，也就是大屏幕下导航是横的，小屏幕下还是横的只不过变小了</li><li>优点：理想状态是所有屏幕的高宽比和最初的设计高宽比一样，或者相差不多，完美适应</li><li>缺点：碰到重视高度的设计，或者重视元素间间距的设计，那就玩不开了</li></ul></li></ul></li></ul><h3 id="2、如何最小化重绘-repaint-和回流-reflow-（拓展需要掌握）"><a href="#2、如何最小化重绘-repaint-和回流-reflow-（拓展需要掌握）" class="headerlink" title="2、如何最小化重绘(repaint)和回流(reflow)（拓展需要掌握）"></a><strong>2、如何最小化重绘(repaint)和回流(reflow)（拓展需要掌握）</strong></h3><ul><li><p>DOM的增删行为</p><ul><li>比如要给某个父元素添加子元素时,这类的操作都可以引起回流,如何添加多个子元素的时候,可以使用documentfragment</li></ul></li><li><p>几何属性的变化</p><ul><li>比如元素宽高发生了变化,border,字体大小发生了变化,这种直接会引起页面布局变化的操作也会引起回流。如果你要改变多个属性，最好将这些属性定义在一个class中，直接修改class名，这样只用引起一次回流</li></ul></li><li><p>元素的位置变化</p><ul><li>修改一个元素的左右margin，padding之类的操作，所以在做元素位移的动画，不要更改margin之类的属性，使用定位脱离文档流后改变位置会更好</li></ul></li><li><p>获取元素的偏移量属性</p><ul><li>例如获取一个元素的scrollTop、scrollLeft、scrollWidth、offsetTop、offsetLeft、offsetWidth、offsetHeight之类的属性，浏览器为了保证值的正确也会回流取得最新的值，所以如果你要多次操作，最好取完做个缓存</li></ul></li><li><p>避免同步布局事件</p><ul><li><p>当我们访问元素的一些属性的时候，会导致浏览器强制清空队列，进行强制同步布局。举个例子，比如说我们想将一个p标签数组的宽度赋值为一个元素的宽度，我们可能写出这样的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initP</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; paragraphs.length; i++) &#123;<br>        paragraphs[i].style.width = box.offsetWidth + <span class="hljs-string">&#x27;px&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>这段代码看着没有什么问题,但是可能会造成很大的性能问题,在每次循环的时候,都触发了p标签的width属性,这就导致了一个问题,就是在每次循环的时候,浏览器必须使用上次循环中生效的样式更新操作,才能响应本次循环读取的样式操作,每次循环就导致强制浏览器刷新队列机制,可以优化为:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> width = box.offsetWidth;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initP</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; paragraphs.length; i++) &#123;<br>        paragraphs[i].style.width = width + <span class="hljs-string">&#x27;px&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3、对viewport理解"><a href="#3、对viewport理解" class="headerlink" title="3、对viewport理解"></a><strong>3、对viewport理解</strong></h3><ul><li><p><strong>核心定义</strong></p><ul><li>移动设备上的viewport就是设备的屏幕上能用来显示我们的网页的那一块区域，在具体一点，就是浏览器上(也可能是一个app中的webview)用来显示网页的那部分区域，但viewport又不局限于浏览器可视区域的大小，它可能比浏览器的可视区域要大，也可能比浏览器的可视区域要小。在默认情况下，一般来讲，移动设备上的viewport都是要大于浏览器可视区域的，这是因为考虑到移动设备的分辨率相对于桌面电脑来说都比较小，所以为了能在移动设备上正常显示那些传统的为桌面浏览器设计的网站，移动设备上的浏览器都会把自己默认的viewport设为980px或1024px（也可能是其它值，这个是由设备自己决定的），但带来的后果就是浏览器会出现横向滚动条，因为浏览器可视区域的宽度是比这个默认的viewport的宽度要小</li></ul></li><li><p><strong>meta标签</strong></p><ul><li><p>通过设置meta标签,可以设置viewport</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>常用属性</strong></p><p>​    <img src="https://wushuo1031.oss-cn-beijing.aliyuncs.com/img/viewport.png"></p></li></ul><h3 id="4、对二倍图、三倍图的理解和使用"><a href="#4、对二倍图、三倍图的理解和使用" class="headerlink" title="4、对二倍图、三倍图的理解和使用"></a><strong>4、对二倍图、三倍图的理解和使用</strong></h3><ul><li><p><strong>逻辑像素</strong></p><ul><li>就是程序概念的,横向或者纵向的(css px)像素点</li></ul></li><li><p><strong>物理像素</strong></p><ul><li>物理设备屏幕横向或者纵向提供的荧光点的像素点</li><li>在一个设备某个区域内想要显示清晰的条件要素是,设置的<code>逻辑横向像素点</code>,<code>需要刚好填满物理设备提供的物理像素荧光点</code></li></ul></li><li><p><strong>概述</strong></p><ul><li>在早起的屏幕分辨率(物理像素)基本上(iphone3)都是320px(320物理像素点),那个时候1pxcss== 1px物理像素</li><li>由于现在设备不同设备分辨率(物理像素)越来越高,苹果公司退出了,视网膜屏幕,那这种屏幕设备物理又提升了好几倍,这个时候1pxcss单位已经占不满屏幕的物理像素px了</li><li>如何选择多大的css图片? 就是最早期的IPhone 3的横向物理像素320为基础值与该设备的物理像素（屏幕分辨率：一般买手机会有说明）的比值就是你该选用UI设计给的1倍 ，2倍 ,3倍 ,4倍 等图了,比值是1就用1倍， 2就用2倍 依次类推 ),比值可以通过BOM的window对象点devicePixelRatio属性获取到,当前屏幕设备要用多大的倍图</li></ul></li><li><p><strong>图解倍图</strong></p><p><img src="https://wushuo1031.oss-cn-beijing.aliyuncs.com/img/%E5%80%8D%E5%9B%BE1.png"></p></li><li><p><strong>为什么要有2倍图,3倍图?</strong></p><p>​        <img src="https://wushuo1031.oss-cn-beijing.aliyuncs.com/img/2-3%E5%80%8D%E5%9B%BE.png"></p></li><li><p><strong>详细解释</strong></p><p>​        <img src="https://wushuo1031.oss-cn-beijing.aliyuncs.com/img/2-3%E5%80%8D%E5%9B%BE%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8A.png"></p></li><li><p><strong>使用方式</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@mixin</span> bg-image($url) &#123;<br>    <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">$url + &quot;@2x.png&quot;</span>);<br>    <span class="hljs-keyword">@media</span> (<span class="hljs-attribute">-webkit-min-device-pixel-ratio</span>:<span class="hljs-number">3</span>),(<span class="hljs-attribute">min-device-pixel-ratio</span>:<span class="hljs-number">3</span>)&#123;<br>      <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">$url + &quot;@3x.png&quot;</span>)<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="5、在移动端中如何绘制0-5px像素"><a href="#5、在移动端中如何绘制0-5px像素" class="headerlink" title="5、在移动端中如何绘制0.5px像素"></a><strong>5、在移动端中如何绘制0.5px像素</strong></h3><ul><li><p><strong>基本定义</strong></p><p>​        设计师在做设计图的时候都是以iphone6（宽为750物理像素）为基准进行设计的。iphone6的设备像素比（即css像素与物理像素的比例）是2，所以设计师在设计图画了边框为1px的box的时候，相对于css代码来说就是0.5像素。如果用css直接设置边框为0.5px，这种情况下iPhone可以正常显示，但是android下几乎所有的浏览器都会把0.5识别为0，即无边框状态，所以这种方式行不通的</p></li><li><p><strong>代码实现</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>0.5px线实现方法<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span><br><span class="css"> <span class="hljs-comment">/*标准1px边框*/</span></span><br><span class="css"> <span class="hljs-selector-class">.b1</span>&#123;</span><br><span class="css"> <span class="hljs-attribute">height</span>: <span class="hljs-number">40px</span>;</span><br><span class="css"> <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ff0000</span>;</span><br><span class="css"> &#125;</span><br><span class="css"> <span class="hljs-comment">/*1.可以利用利用渐变样式=&gt;实现.5px*/</span></span><br><span class="css"> <span class="hljs-selector-class">.a1</span>&#123;</span><br><span class="css"> <span class="hljs-attribute">height</span>: <span class="hljs-number">1px</span>;</span><br><span class="css"> <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">20px</span>;</span><br><span class="css"> <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">linear-gradient</span>(<span class="hljs-number">0deg</span>, <span class="hljs-number">#f00</span> <span class="hljs-number">50%</span>, transparent <span class="hljs-number">50%</span>);</span><br><span class="css"> &#125;</span><br><span class="css"> <span class="hljs-comment">/*2.可以利用缩放-发虚=&gt;实现.5px*/</span></span><br><span class="css"> <span class="hljs-selector-class">.a2</span>&#123;</span><br><span class="css"> <span class="hljs-attribute">height</span>: <span class="hljs-number">1px</span>;</span><br><span class="css"> <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">20px</span>;</span><br><span class="css"> <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f00</span>;</span><br><span class="css"> -webkit-<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scaleY</span>(.<span class="hljs-number">5</span>);</span><br><span class="css"> <span class="hljs-attribute">transform</span>:<span class="hljs-built_in">scaleY</span>(.<span class="hljs-number">5</span>);</span><br><span class="css"> &#125;</span><br><span class="css"> <span class="hljs-comment">/*3.四条边框都需要的样式*/</span></span><br><span class="css"> <span class="hljs-selector-class">.scale-half</span> &#123;</span><br><span class="css"> <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">20px</span>;</span><br><span class="css"> <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="css"> <span class="hljs-attribute">border</span>:<span class="hljs-number">1px</span> solid <span class="hljs-number">#f00</span>;</span><br><span class="css"> -webkit-<span class="hljs-attribute">transform-origin</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span>;</span><br><span class="css"> <span class="hljs-attribute">transform-origin</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span>;</span><br><span class="css"> -webkit-<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(.<span class="hljs-number">5</span>, .<span class="hljs-number">5</span>);</span><br><span class="css"> <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(.<span class="hljs-number">5</span>, .<span class="hljs-number">5</span>);</span><br><span class="css"> &#125;</span><br><span class="css"> <span class="hljs-comment">/*4.给伪元素添加设置边框*/</span></span><br><span class="css"> <span class="hljs-selector-class">.border3</span>&#123;</span><br><span class="css"> <span class="hljs-attribute">position</span>: relative;</span><br><span class="css"> &#125;</span><br><span class="css"> <span class="hljs-selector-class">.border3</span>:before&#123;</span><br><span class="css"> content: <span class="hljs-string">&#x27;&#x27;</span>;</span><br><span class="css"> <span class="hljs-attribute">position</span>: absolute;</span><br><span class="css"> <span class="hljs-attribute">width</span>: <span class="hljs-number">200%</span>;</span><br><span class="css"> <span class="hljs-attribute">height</span>: <span class="hljs-number">200%</span>;</span><br><span class="css"> <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid blue;</span><br><span class="css"> -webkit-<span class="hljs-attribute">transform-origin</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span>;</span><br><span class="css"> -moz-<span class="hljs-attribute">transform-origin</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span>;</span><br><span class="css"> -ms-<span class="hljs-attribute">transform-origin</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span>;</span><br><span class="css"> -o-<span class="hljs-attribute">transform-origin</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span>;</span><br><span class="css"> <span class="hljs-attribute">transform-origin</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span>;</span><br><span class="css"> -webkit-<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(.<span class="hljs-number">5</span>, .<span class="hljs-number">5</span>);</span><br><span class="css"> -ms-<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(.<span class="hljs-number">5</span>, .<span class="hljs-number">5</span>);</span><br><span class="css"> -o-<span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(.<span class="hljs-number">5</span>, .<span class="hljs-number">5</span>);</span><br><span class="css"> <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(.<span class="hljs-number">5</span>, .<span class="hljs-number">5</span>);</span><br><span class="css"> -webkit-<span class="hljs-attribute">box-sizing</span>: border-box;</span><br><span class="css"> -moz-<span class="hljs-attribute">box-sizing</span>: border-box;</span><br><span class="css"> <span class="hljs-attribute">box-sizing</span>: border-box;</span><br><span class="css"> &#125;</span><br><span class="css"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;b1&quot;</span>&gt;</span>正常1px边框<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;a1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;a2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;scale-half&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;border3&quot;</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span>伪类设置的边框<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="js基础"><a href="#js基础" class="headerlink" title="js基础"></a>js基础</h2><h3 id="1、JavaScript-内置的常用对象有哪些？并列举该对象常用的方法"><a href="#1、JavaScript-内置的常用对象有哪些？并列举该对象常用的方法" class="headerlink" title="1、JavaScript 内置的常用对象有哪些？并列举该对象常用的方法"></a><strong>1、JavaScript 内置的常用对象有哪些？并列举该对象常用的方法</strong></h3><ul><li><strong>Math(数学对象)</strong><ul><li>abs(返回绝对值)</li><li>ceil(向上取整)</li><li>floor(向下舍入)</li><li>max(最大值)</li><li>min(最小值)</li><li>rendom(返回0~1之间的随机数)</li></ul></li><li><strong>Date(日期对象)</strong><ul><li>Date(返回当前日期)</li><li>getDate(返回一个月中的某一天)</li><li>getMonth(返回对象中的月份)</li><li>getHours(返回对象中的小时)</li><li>getMinutes(返回对象中的分钟)</li></ul></li><li><strong>String(字符串对象)</strong><ul><li>concat(链接字符串)</li><li>trim(去除字符串两侧留白)</li><li>indexOf(检索字符串索引)</li><li>replace(替换与正则匹配的字符串)</li><li>split(把字符串切割为数组)</li></ul></li><li><strong>Array(数组对象)</strong><ul><li>pop(末尾删除)</li><li>push(末尾添加)</li><li>shift(删除数组第一个元素)</li><li>unshifr(添加到数组中第一的位置)</li><li>sort(对数组进行排序)</li><li>reverse(翻转数组)</li></ul></li></ul><h3 id="2、如何区分数组和对象"><a href="#2、如何区分数组和对象" class="headerlink" title="2、如何区分数组和对象"></a><strong>2、如何区分数组和对象</strong></h3><ul><li><strong>区分数组</strong><ul><li>Array.prototype.isPrototypeOf()<ul><li>通过原型的方式,判断Array是否存在于Object的原型中</li></ul></li><li>isArray()<ul><li>该方法可以判断,返回的是一个布尔值</li></ul></li></ul></li><li><strong>区分对象</strong><ul><li>Object.prototype.toString.call()<ul><li>因为toString为Object的原型方法,而Array和Function等类型作为Object的实例,都重写了该方法,不同的对象类型调用时,调用的是重写之后的toString()方法,所以不能得到其对象类型,只能把Obj转换为字符串类型</li></ul></li></ul></li></ul><h3 id="3、JavaScript-中的作用域、预解析与变量声明提升"><a href="#3、JavaScript-中的作用域、预解析与变量声明提升" class="headerlink" title="3、JavaScript 中的作用域、预解析与变量声明提升?"></a><strong>3、JavaScript 中的作用域、预解析与变量声明提升?</strong></h3><ul><li><p><strong>作用域</strong></p><ul><li>全局作用域<code>在函数外部的区域,都可以称之为全局作用域</code></li><li>局部作用域<code>在函数内部的区域,都可以称之为局部作用域</code></li><li>块级作用域<code>es6中新增了块级作用域,把&#123;&#125;都可以视为块级作用域</code></li></ul></li><li><p><strong>预解析</strong></p><ul><li>该机制是javaScript中存在的一种机制,会把函数声明,和使用Var声明的变量,进行提升</li></ul></li><li><p><strong>变量声明提升</strong></p><ul><li>只要使用了var声明,就会存在变量声明提升的问题</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(num)<span class="hljs-comment">// undefined</span><br>  <span class="hljs-keyword">var</span> num = <span class="hljs-number">20</span>;<br>  <span class="hljs-comment">// 解析为:</span><br>  <span class="hljs-keyword">var</span> num;<br>  <span class="hljs-built_in">console</span>.log(num) <span class="hljs-comment">// 声明了变量,但是未赋值,undefined</span><br>  num = <span class="hljs-number">20</span><br>   *********************************分割线*******************************************<br>      <span class="hljs-comment">// 函数表达式中,使用了var关键字,会报错</span><br>  fn() <span class="hljs-comment">// TypeError: fn is not a function</span><br>      <span class="hljs-keyword">var</span> fn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;啊~我提升了&#x27;</span>)<br>      &#125;<br>      <span class="hljs-comment">// 解析为</span><br>      <span class="hljs-keyword">var</span> fn<br>      fn()<br>      fn =<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;啊~我提升了&#x27;</span>)<br>      &#125;<br></code></pre></td></tr></table></figure><ul><li>函数声明也会被预解析机制影响,导致函数声明提升<code>函数虽然提前调用,但是不会报错,印证了函数声明存在预解析</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">fn() <span class="hljs-comment">// 输出: 预解析中的函数声明</span><br> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;预解析中的函数声明&#x27;</span>)<br> &#125;<br> <span class="hljs-comment">// 解析为:</span><br> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;预解析中的函数声明&#x27;</span>)<br> &#125;<br> fn()<br></code></pre></td></tr></table></figure><ul><li>函数名重复的情况下<code>如果两个名称相同,会保留后者</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 两个函数名称相同,那么会输出最后函数的结果</span><br>  fn()<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我是fn函数A&#x27;</span>)<br>&#125;<br>  fn()<br> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我是fn函数B&#x27;</span>)<br> &#125;<br><span class="hljs-comment">// 输出: 两个: 我是fn函数B</span><br><br><span class="hljs-comment">//解析为:</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我是fn函数A&#x27;</span>)<br>      &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我是fn函数B&#x27;</span>)<br>  &#125;<br> fn()<br> fn()<br></code></pre></td></tr></table></figure><ul><li>函数名和变量名重复:<code>只会对函数进行提升,变量忽略,并且不会发生调用</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(fnc) <span class="hljs-comment">// 输出函数体: fucntion fn () &#123; console.log(&#x27;我是函数&#x27;) &#125;</span><br>     <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fnc</span>(<span class="hljs-params"></span>) </span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我是函数&#x27;</span>)<br>     &#125;<br>     <span class="hljs-keyword">var</span> fnc = <span class="hljs-string">&#x27;我是一个字符串&#x27;</span><br>     <span class="hljs-comment">// 解析为:</span><br>     <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fnc</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br>     <span class="hljs-built_in">console</span>.log(fnc)<br>     fnc = <span class="hljs-string">&#x27;我是一个字符串&#x27;</span><br>     <span class="hljs-comment">//总结: 只会对函数进行提升,变量会被忽略,并且不会发生调用</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="4、如何实现数组的随机排序"><a href="#4、如何实现数组的随机排序" class="headerlink" title="4、如何实现数组的随机排序"></a><strong>4、如何实现数组的随机排序</strong></h3><ul><li><p><strong>使用sort()结合Math.random()</strong></p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>];<br>       arr.sort(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.random()-<span class="hljs-number">0.5</span><br>       &#125;)<br>       <span class="hljs-built_in">console</span>.log(arr)<br></code></pre></td></tr></table></figure></li><li><p><strong>循环过程中通过Math.random()函数产生的随机值，在数组中这个随机值位置的数和arr[i]位置的数据交换，循环结束，产生随机数组</strong></p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>];<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">randSort1</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = arr.length; i &lt; len; i++) &#123;<br>        <span class="hljs-keyword">var</span> rand = <span class="hljs-built_in">parseInt</span>(<span class="hljs-built_in">Math</span>.random() * len);<br>        <span class="hljs-keyword">var</span> temp = arr[rand];<br>        arr[rand] = arr[i];<br>        arr[i] = temp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(randSort1(arr))<br></code></pre></td></tr></table></figure></li></ul><h3 id="5、说一下数组的常用方法有哪些"><a href="#5、说一下数组的常用方法有哪些" class="headerlink" title="5、说一下数组的常用方法有哪些?"></a><strong>5、说一下数组的常用方法有哪些?</strong></h3><ul><li>psuh()末尾追加</li><li>pop()末尾删除</li><li>sort()数组排序</li><li>reverse()翻转数组</li><li>shift()头部删除</li><li>unshift()头部添加</li><li>forEach()循环</li><li>filter()过滤</li><li>reduce()计算总和</li></ul><h3 id="6、Let、Const、Var三者区别？（解决了什么问题）"><a href="#6、Let、Const、Var三者区别？（解决了什么问题）" class="headerlink" title="6、Let、Const、Var三者区别？（解决了什么问题）"></a><strong>6、Let、Const、Var三者区别？（解决了什么问题）</strong></h3><ul><li><strong>区别如下</strong><ul><li>变量提升<ul><li>var声明的变量都会存在变量提升问题,但是let和const不会</li></ul></li><li>重复声明<ul><li>使用var声明的变量,可以重复声明</li><li>let和const不能重复声明</li></ul></li><li>作用域<ul><li>let/const都会产生块级作用域,var声明的变量则不会发生</li></ul></li><li>赋值操作<ul><li>var声明的变量,可以先声明,在去赋值,如果未赋值,出现undefined</li><li>let声明的变量,可以进行改变,类型和值都可以改变</li><li>const声明的变量,不可以进行改变,一旦进行改变,就必须立即初始化,不能留到以后赋值</li></ul></li><li>其它<ul><li>conts/let声明的变量,都会存在暂时性死区的问题</li><li>const保存的仅是对象的指针,const仅会保证指针不会发生改变,所以,当修改一个对象的属性,并不会改变对象的指针,也就是说,const定义的引用类型,只要指针不发生变化,其它的改变的都是允许的</li></ul></li></ul></li></ul><h3 id="7、JS中eventLoop的循环机制？-面试常问"><a href="#7、JS中eventLoop的循环机制？-面试常问" class="headerlink" title="7、JS中eventLoop的循环机制？ (面试常问)"></a><a href="https://zhuanlan.zhihu.com/p/55511602"><strong>7、JS中eventLoop的循环机制？ (面试常问)</strong></a></h3><p><a href="https://www.bilibili.com/video/BV1kf4y1U7Ln?from=search&amp;seid=16025121856462666305">https://www.bilibili.com/video/BV1kf4y1U7Ln?from=search&amp;seid=16025121856462666305</a></p><p><a href="https://www.bilibili.com/video/BV13E411B7yp?from=search&amp;seid=16025121856462666305">https://www.bilibili.com/video/BV13E411B7yp?from=search&amp;seid=16025121856462666305</a></p><ul><li><p><strong>堆(Heep)</strong></p><ul><li><p>堆是一种数据结构,是利用二叉树维护的一组数据,堆分为两种,一种为最大堆,一种为最小堆,将根节点最大的堆称之为最大堆或大根堆,根节点最小的堆,叫做最小堆或者小根堆,堆是线性数据结构,相当于一维数组,有唯一后继</p><p><img src="https://wushuo1031.oss-cn-beijing.aliyuncs.com/img/Heap.png"></p></li></ul></li><li><p><strong>栈(Stack)</strong></p><ul><li><p>栈,是在计算机科学中限定仅在表尾进行插入,或者是删除操作的线性表,栈是一种数据结构,它按照后进先出的原则存储数据,<code>先进入的数据压入栈底</code>,<code>最后的数据在栈顶</code>,需要读数据的时候,从栈顶开始弹出数据,栈是只能在某一端插入和删除的特殊线性表</p><p><img src="https://wushuo1031.oss-cn-beijing.aliyuncs.com/img/Stack.png"></p></li></ul></li><li><p><strong>队列(Queue)</strong></p><ul><li><p>队列,其特殊之处在于,只允许在表的前端(front)进行删除操作,而在表尾(rear)进行插入操作,和堆栈一样,是一种受限的线性表,进行插入操作的端,叫做队尾,进行删除操作的端,叫做队头,队列中不存在元素时,称之为空队列</p></li><li><p>队列的数据元素,称之为队列元素,在队列中<code>插入一个队列元素,称之为入队,</code>从<code>队列中删除一个元素,称之为出队,</code>因为<strong>队列只允许在一端插入,在另外一端删除</strong>,所以只有最早进入队列的元素,才能从队列中删除,故队列称之为<code>先进先出</code></p><p><img src="https://wushuo1031.oss-cn-beijing.aliyuncs.com/img/Queue%E9%98%9F%E5%88%97.jpg"></p></li></ul></li><li><p><strong>宏任务(MacroTask)</strong></p><ul><li><code>script</code>全部代码、<code>setTimeout</code>、<code>setInterval</code>、<code>setImmediate</code>（浏览器暂时不支持，只有IE10支持，具体可见<code>MDN</code>）、<code>I/O</code>、<code>UI Rendering</code></li></ul></li><li><p><strong>微任务(MicroTask)</strong></p><ul><li><code>Process.nextTick（Node独有）</code>、<code>Promise</code>、<code>Object.observe(废弃)</code>、<code>MutationObserver</code></li></ul></li><li><p><strong>浏览器中的EventLoop</strong></p><ul><li><code>Javascript</code> 有一个 <code>main thread</code> 主线程和 <code>call-stack</code> 调用栈(执行栈)，所有的任务都会被放到调用栈等待主线程执行</li></ul></li><li><p><strong>js调用栈</strong></p><ul><li>JS调用栈采用的是<code>后进先出</code>的规则，当函数执行的时候，会被添加到栈的顶部，当执行栈执行完成后，就会从栈顶移出，直到栈内被清空</li></ul></li><li><p><strong>同步任务和异步任务</strong></p><ul><li><p><code>Javascript</code>单线程任务被分为<strong>同步任务</strong>和<strong>异步任务</strong>，同步任务会在调用栈中按照顺序等待主线程依次执行，异步任务会在异步任务有了结果后，将注册的回调函数放入任务队列中等待主线程空闲的时候（调用栈被清空），被读取到栈内等待主线程的执行</p><p><img src="https://wushuo1031.oss-cn-beijing.aliyuncs.com/img/E1.jpg"></p></li><li><p>任务队列<code>Task Queue</code>，即队列，是一种先进先出的一种数据结构</p><p><img src="https://wushuo1031.oss-cn-beijing.aliyuncs.com/img/E2.jpg"></p></li><li><p><strong>事件循环的事件模型</strong></p><ul><li>选择当前要执行的任务队列，选择任务队列中最先进入的任务，如果任务队列为空即<code>null</code>，则执行跳转到微任务（<code>MicroTask</code>）的执行步骤。</li><li>将事件循环中的任务设置为已选择任务。</li><li>执行任务。</li><li>将事件循环中当前运行任务设置为null。</li><li>将已经运行完成的任务从任务队列中删除。</li><li>microtasks步骤：进入microtask检查点。</li><li>更新界面渲染。</li><li>返回第一步。</li></ul></li><li><p><strong>执行栈进入microtask检查点时,用户代理会执行以下步骤</strong></p><ul><li>设置microtask检查点标志为true。</li><li>当事件循环<code>microtask</code>执行不为空时：选择一个最先进入的<code>microtask</code>队列的<code>microtask</code>，将事件循环的<code>microtask</code>设置为已选择的<code>microtask</code>，运行<code>microtask</code>，将已经执行完成的<code>microtask</code>为<code>null</code>，移出<code>microtask</code>中的<code>microtask</code>。</li><li>清理IndexDB事务</li><li>设置进入microtask检查点的标志为false</li><li>   <img src="https://wushuo1031.oss-cn-beijing.aliyuncs.com/img/E3.gif"></li><li>执行栈在执行完同步任务以后,查看执行栈是否为空,如果执行栈为空,就会去执行<code>task(宏任务)</code>每次宏任务执行完毕以后,检查是否存在<code>微任务(microTask)</code>队列是否为空,如果不为空的话,会按照<code>先进先出</code>的规则全部执行完毕<code>微任务(microTask)</code>后,设置<code>微任务(microTask)</code>队列为<code>null</code>然后再去执行宏任务,如此循环,就形成了<code>事件循环(EventLoop)</code></li></ul></li><li><p><strong>举个栗子</strong></p><ul><li><p>请说出以下代码输出的结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;1&#x27;</span>);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;2&#x27;</span>);<br>&#125;, <span class="hljs-number">0</span>);<br><span class="hljs-comment">// resolve是一个同步任务,后面虽然调用了then方法,但是执行顺序还是先去执行同步任务,然后再去执行异步任务</span><br><span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;3&#x27;</span>);<br>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;4&#x27;</span>);<br>&#125;);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;5&#x27;</span>);<br><span class="hljs-comment">// 1 5 3 4 2</span><br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>第一次执行</p><ul><li>(执行同步代码,将<code>宏任务(Task)</code>和<code>微任务(Microtasks)</code>划分到各自的队列中)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">Tasks：run script、 <span class="hljs-built_in">setTimeout</span> callback<br><br>Microtasks：<span class="hljs-built_in">Promise</span> then<br><br>JS stack: script<br><span class="hljs-attr">Log</span>: script start、script end。<br></code></pre></td></tr></table></figure></li></ul></li><li><p>第二次执行</p><ul><li>执行宏任务后，检测到微任务(<code>Microtasks</code>)队列中不为空，执行<code>Promise1</code>，执行完成<code>Promise1</code>后，调用<code>Promise2.then</code>，放入微任务(<code>Microtasks</code>)队列中，再执行<code>Promise2.then</code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">Tasks：run script、 <span class="hljs-built_in">setTimeout</span> callback<br><br>Microtasks：Promise2 then<br><br>JS stack: Promise2 callback<br><span class="hljs-attr">Log</span>: script start、script end、promise1、promise2<br></code></pre></td></tr></table></figure></li></ul></li><li><p>第三次执行</p><ul><li>当微任务(<code>Microtasks</code>)队列中为空时，执行宏任务（<code>Tasks</code>），执行<code>setTimeout callback</code>，打印日志<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">Tasks：<span class="hljs-built_in">setTimeout</span> callback<br><br>Microtasks：<br><br>JS stack: <span class="hljs-built_in">setTimeout</span> callback<br><span class="hljs-attr">Log</span>: script start、script end、promise1、promise2、<span class="hljs-built_in">setTimeout</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>第四次执行</p><ul><li>清空<strong>Tasks</strong>队列和<code>JS stack</code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">Tasks：<span class="hljs-built_in">setTimeout</span> callback<br><br>Microtasks：<br><br>JS stack: <br>Log: script start、script end、promise1、promise2、<span class="hljs-built_in">setTimeout</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="8、ES5和ES6的继承区别？（class类）"><a href="#8、ES5和ES6的继承区别？（class类）" class="headerlink" title="8、ES5和ES6的继承区别？（class类）"></a><strong>8、ES5和ES6的继承区别？（class类）</strong></h3><ul><li><p><strong>ES5继承</strong></p><ul><li><p>寄生组合式继承(基本思想)</p><ul><li>定义祖先</li><li>定义祖先可继承的变量</li><li>定义继承的类（构造函数），并在类中调用组件的方法</li><li>使用 prototyoe定义继承关系</li><li>重新将constructor指向自己</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a</span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.varA = a;<br>&#125;<br><br><span class="hljs-comment">//定义祖先对象的可继承属性和方法</span><br>A.prototype = &#123;<br>    <span class="hljs-attr">varA</span> : <span class="hljs-literal">null</span>,<br>    <span class="hljs-attr">doSomeThing</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.varA);<br>    &#125;,<br>&#125;<br><br><span class="hljs-comment">//定义继承函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">B</span>(<span class="hljs-params">a,b</span>)</span>&#123;<br>    A.call(<span class="hljs-built_in">this</span>,a);<br>    <span class="hljs-built_in">this</span>.varB = b;<br>&#125;<br><span class="hljs-comment">//定义继承关系</span><br>B.prototype = <span class="hljs-built_in">Object</span>.create(A.prototype)<br>B.prototype.doSomeThing = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.varB);<br>&#125;<br><span class="hljs-comment">//绑定Constructor</span><br>B.prototype.constructor = B;<br><br><span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> B(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>);<br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> A(<span class="hljs-string">&#x27;a&#x27;</span>);<br>a.doSomeThing();<br>b.doSomeThing();<br></code></pre></td></tr></table></figure><p><img src="https://wushuo1031.oss-cn-beijing.aliyuncs.com/img/ES5%E7%BB%A7%E6%89%BF.png"></p></li></ul></li><li><p><strong>ES6继承</strong></p><ul><li><p>基本思想</p><ul><li>Class之间通过使用extends关键字，这比通过修改原型链实现继承，要方便清晰很多</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Colorpoint</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Point</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">x,y,color</span>)</span>&#123;<br>        <span class="hljs-built_in">super</span>(x,y); <span class="hljs-comment">//调用父类的constructor(x,y)</span><br>        <span class="hljs-built_in">this</span>.color = color<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">toString</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-comment">//调用父类的方法</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.color + <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-built_in">super</span>.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>注意事项</p><ul><li>子类必须在constructo中调用super方法，否则新建实例时会报错,这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工，如果不调用super方法，子类就得不到this对象,因此，只有调用super之后，才可以使用this关键字</li></ul><p><img src="https://wushuo1031.oss-cn-beijing.aliyuncs.com/img/ES6%E7%BB%A7%E6%89%BF.png"></p></li><li><p>区别和不同</p><ul><li><p>类内部定义的方法,是不可枚举的,和ES5不同</p></li><li><p>类不存在变量提升,这一点和ES5不同</p></li><li><p><code>类相当于实例的原型,所有在类中定义的方法,都会被实例继承,</code>如果在一个方法前,加上static关键字,就表示该方法不会被实例继承,而是直接通过类来调用,这就称之为静态方法</p></li><li><p><code>es5的继承,实质是先创造子类的实例对象this,然后再将父类的方法添加到this上面,es6的继承机制完全不同,实质先创造父类的实例对象this,</code>所以必须先调用super方法`,然后再用子类的构造函数修改this</p></li><li><p>类的prototype属性和proto属性,大多数浏览器的ES5实现之中,每一个对象都有proto属性,指向对应的构造函数的prototype属性,Class作为构造函数的语法糖,同时有prototype属性proto属性,因此同时存在两条继承链</p><ul><li><p>子类的proto属性,表示构造函数的继承,总是指向父类</p></li><li><p>子类的prototype属性的proto属性,表示方法的继承,总是指向父类的prototype属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。</span><br><span class="hljs-comment">//只要你的代码写在类或模块之中，就只有严格模式可用。</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;<br>    <span class="hljs-comment">//constructor方法，就是构造方法</span><br>    <span class="hljs-comment">//如果没有定义constructor方法，JS会自动为其添加</span><br>    <span class="hljs-comment">//constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。</span><br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">x, y</span>)</span> &#123;<br>        <span class="hljs-comment">//this代表实例对象</span><br>        <span class="hljs-built_in">this</span>.x = x;<br>        <span class="hljs-built_in">this</span>.y = y;<br>        <span class="hljs-built_in">this</span>.tohello = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;hello&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//类的方法，不需要加上function这个关键字</span><br>    <span class="hljs-comment">//下面代码中，toString方法是Point类内部定义的方法，它是不可枚举的。</span><br>    <span class="hljs-comment">//这一点与 ES5 的行为不一致。</span><br>    <span class="hljs-function"><span class="hljs-title">toString</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;(&#x27;</span> + <span class="hljs-built_in">this</span>.x + <span class="hljs-string">&#x27;, &#x27;</span> + <span class="hljs-built_in">this</span>.y + <span class="hljs-string">&#x27;)&#x27;</span>;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-comment">//完全可以看成构造函数的另外一种写法</span><br>Point === Point.prototype.constructor <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">//构造函数的prototype属性，在 ES6 的“类”上面继续存在。</span><br><span class="hljs-comment">//事实上，类的所有方法都定义在类的prototype属性上面。</span><br><span class="hljs-comment">//除非显示定义在类上面</span><br><span class="hljs-comment">//类必须使用new调用，否则会报错。</span><br><span class="hljs-comment">//这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。</span><br><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> Point(<span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>);<br>p.tohello();<br><span class="hljs-comment">// p.prototype.tohello();  //false</span><br><br><span class="hljs-comment">//与 ES5 一样，类的所有实例共享一个原型对象。</span><br><span class="hljs-keyword">var</span> p1 = <span class="hljs-keyword">new</span> Point(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><span class="hljs-keyword">var</span> p2 = <span class="hljs-keyword">new</span> Point(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>);<br><br>p1.__proto__ === p2.__proto__<br><span class="hljs-comment">//true</span><br><span class="hljs-comment">//上面代码中，p1和p2都是Point的实例，它们的原型都是Point.prototype，所以__proto__属性是相等的。</span><br><span class="hljs-comment">//这也意味着，可以通过实例的__proto__属性为“类”添加方法。</span><br><span class="hljs-comment">//__proto__ 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，</span><br><span class="hljs-comment">//虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，</span><br><span class="hljs-comment">//但依旧不建议在生产中使用该属性，避免对环境产生依赖。</span><br><span class="hljs-comment">//生产环境中，我们可以使用 Object.getPrototypeOf 方法来获取实例对象的原型，然后再来为原型添加方法/属性。</span><br><br><span class="hljs-comment">//不推荐下面的做法</span><br>p1.__proto__.printName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Oops&#x27;</span><br>&#125;;<br><br>p1.printName() <span class="hljs-comment">// &quot;Oops&quot;</span><br>p2.printName() <span class="hljs-comment">// &quot;Oops&quot;</span><br><br><span class="hljs-keyword">var</span> p3 = <span class="hljs-keyword">new</span> Point(<span class="hljs-number">4</span>, <span class="hljs-number">2</span>);<br>p3.printName() <span class="hljs-comment">// &quot;Oops&quot;</span><br><span class="hljs-comment">//类不存在变量提升（hoist），这一点与 ES5 完全不同。</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span> </span>&#123;<br>    <span class="hljs-comment">//静态方法，只能通过类来调用</span><br>    <span class="hljs-comment">//父类的静态方法也会被子类继承</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">classMethod</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hello&#x27;</span>;<br>    &#125;<br>&#125;<br><br>Foo.classMethod() <span class="hljs-comment">// &#x27;hello&#x27;</span><br><br><span class="hljs-keyword">var</span> foo = <span class="hljs-keyword">new</span> Foo();<br><span class="hljs-comment">//  foo.classMethod()</span><br><span class="hljs-comment">// TypeError: foo.classMethod is not a function</span><br><br><span class="hljs-comment">//实现继承</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ColorPoint</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Point</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">x,y,color</span>)</span>&#123;<br>        <span class="hljs-comment">//调用父类的构造函数，用来新建父类的this对象</span><br>        <span class="hljs-comment">//super作为函数调用时，返回的是子类B的实例，super内部的this指向B</span><br>        <span class="hljs-comment">//super相当于 A.prototype.constructor.call(this)</span><br>        <span class="hljs-comment">//super作为函数只能用在constructor中</span><br>        <span class="hljs-built_in">super</span>(x,y);<br><br>        <span class="hljs-comment">//子类必须使用super方法，否则子类没有自己的this对象</span><br>        <span class="hljs-comment">//继承父类的this对象然后进行加工</span><br>        <span class="hljs-built_in">this</span>.color = color;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">toString</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-comment">//super作为对象使用时，指向父类的原型对象。</span><br>        <span class="hljs-comment">//在静态方法中指向父类</span><br>        <span class="hljs-comment">//定义在父类实例上的方法是没办法用的</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.color + <span class="hljs-string">&#x27; &#x27;</span> +<span class="hljs-built_in">super</span>.toString();<span class="hljs-comment">//调用父类的方法</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//可以使用getPrototypeOf方法来获取父类</span><br><span class="hljs-built_in">Object</span>.getPrototypeOf(ColorPoint) === Point<br><br>ColorPoint.__proto__ == Point; <span class="hljs-comment">//true</span><br>ColorPoint.prototype.__proto__ == Point.prototype;<span class="hljs-comment">//true</span><br><br><span class="hljs-comment">//这里和es5不一样</span><br><span class="hljs-comment">//对象有属性__proto__,指向该对象的构造函数的原型对象。</span><br><span class="hljs-comment">//方法除了有属性__proto__,还有属性prototype，prototype指向该方法的原型对象。</span><br><br><span class="hljs-keyword">var</span> p1 = <span class="hljs-keyword">new</span> Point(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><span class="hljs-keyword">var</span> p2 = <span class="hljs-keyword">new</span> ColorPoint(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;red&#x27;</span>);<br><br><span class="hljs-comment">// p2.__proto__ === p1.__proto__ // false</span><br>p2.__proto__.__proto__ === p1.__proto__ <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li></ul><h3 id="9、箭头函数"><a href="#9、箭头函数" class="headerlink" title="9、箭头函数"></a><strong>9、箭头函数</strong></h3><ul><li><p>箭头函数是ES6中新增的一种声明函数的方式,和普通函数主要存在以下区别,分别是<code>书写形式区别</code>,<code>this指向</code>,<code>参数语法区别</code></p></li><li><p>语法区别</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1- es5中声明函数的方式</span><br>      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">let</span> num = <span class="hljs-number">20</span><br>        <span class="hljs-built_in">console</span>.log(num)<br>        <span class="hljs-keyword">return</span> num<br>      &#125;<br>      fn()<br><br><span class="hljs-comment">// 2- es6中箭头函数</span><br>      <span class="hljs-keyword">let</span> fn2 = <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> num = <span class="hljs-number">20</span><br>        <span class="hljs-built_in">console</span>.log(num)<br>        <span class="hljs-keyword">return</span> num<br>      &#125;<br>      fn2()<br></code></pre></td></tr></table></figure></li><li><p>this指向区别</p><ul><li>箭头函数内部的this根据词法作用域,由上下文确定</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1- 普通函数 </span><br><span class="hljs-keyword">let</span> Person = &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;jack&#x27;</span>,<br>        <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>,<br>        <span class="hljs-attr">sayHi</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>          <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>) <span class="hljs-comment">// &#123;name: &quot;jack&quot;, age: 20, sayHi: ƒ&#125;</span><br>          <span class="hljs-keyword">var</span> fn = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>) <span class="hljs-comment">// window</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name + <span class="hljs-built_in">this</span>.age)<br>          &#125;<br>          <span class="hljs-keyword">return</span> fn()<br>        &#125;,<br>      &#125;<br>      Person.sayHi()<br></code></pre></td></tr></table></figure><ul><li>使用箭头函数方式</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> Person = &#123;<br>       <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;jack&#x27;</span>,<br>       <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>,<br>       <span class="hljs-attr">sayHi</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>         <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>) <span class="hljs-comment">// &#123;name: &quot;jack&quot;, age: 20, sayHi: ƒ&#125;</span><br>         <span class="hljs-keyword">var</span> fn = <span class="hljs-function">() =&gt;</span> &#123;<br>           <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>) <span class="hljs-comment">// &#123;name: &quot;jack&quot;, age: 20, sayHi: ƒ&#125;</span><br>           <span class="hljs-keyword">return</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name + <span class="hljs-built_in">this</span>.age) <span class="hljs-comment">// jack 20</span><br>         &#125;<br>         <span class="hljs-keyword">return</span> fn()<br>       &#125;,<br>     &#125;<br>     Person.sayHi()<br></code></pre></td></tr></table></figure></li><li><p>参数区别</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 3- 参数区别</span><br><span class="hljs-comment">// 3-1 没有参数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br><span class="hljs-keyword">let</span> fn = <span class="hljs-function">() =&gt;</span> &#123;&#125;<br>  <br><span class="hljs-comment">// 3-2 单个参数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">data</span>) </span>&#123;&#125;<br><span class="hljs-keyword">let</span> fn = <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;&#125;<br>  <br><span class="hljs-comment">// 3-3 多个参数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">data, value</span>) </span>&#123;&#125;<br><span class="hljs-keyword">let</span> fn = <span class="hljs-function">(<span class="hljs-params">data, value</span>) =&gt;</span> &#123;&#125;<br>  <br><span class="hljs-comment">// 3-4 可变参数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">data, value, ...<span class="hljs-built_in">arguments</span></span>) </span>&#123;&#125;<br><span class="hljs-keyword">let</span> fn = <span class="hljs-function">(<span class="hljs-params">data, value, ...<span class="hljs-built_in">arguments</span></span>) =&gt;</span> &#123;&#125;<br>  <br></code></pre></td></tr></table></figure></li></ul><h2 id="Webapi"><a href="#Webapi" class="headerlink" title="Webapi"></a>Webapi</h2><h3 id="1、如何阻止事件冒泡"><a href="#1、如何阻止事件冒泡" class="headerlink" title="1、如何阻止事件冒泡"></a><strong>1、如何阻止事件冒泡</strong></h3><ul><li>标准解决的方式为:  e.stopPropagation() </li><li>兼容IE的方式为:  e.cancelBubble = true</li><li>return false的说明: return false的方式,在原生js中只会阻止<code>默认行为,不会阻止事件冒泡</code>,但是在jquery中,可以做到<code>阻止事件冒泡,也可以阻止默认行为</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stopBubble</span>(<span class="hljs-params">e</span>) </span>&#123; <br><span class="hljs-comment">//如果提供了事件对象，则这是一个非IE浏览器 </span><br><span class="hljs-keyword">if</span> ( e &amp;&amp; e.stopPropagation ) &#123;<br>    <span class="hljs-comment">//因此它支持W3C的stopPropagation()方法 </span><br>    e.stopPropagation(); <br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>     <span class="hljs-comment">//否则，我们需要使用IE的方式来取消事件冒泡 </span><br>    <span class="hljs-built_in">window</span>.event.cancelBubble = <span class="hljs-literal">true</span>; <br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="2、谈谈事件委托的理解"><a href="#2、谈谈事件委托的理解" class="headerlink" title="2、谈谈事件委托的理解"></a><strong>2、谈谈事件委托的理解</strong></h3><ul><li>事件委托就是,利用事件冒泡的特性，将本应该注册在子元素上的处理事件注册在父元素上，这样点击子元素时发现其本身没有相应事件就到父元素上寻找作出相应。</li><li>这样做的优势有：1.减少DOM操作，提高性能 2.随时可以添加子元素，添加的子元素会自动有相应的处理事件</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;ie=edge&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;btn&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;添加&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;ul1&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>111<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>222<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>333<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>444<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">      <span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">        <span class="hljs-keyword">var</span> oBtn = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;btn&#x27;</span>)</span><br><span class="javascript">        <span class="hljs-keyword">var</span> oUl = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;ul1&#x27;</span>)</span><br><span class="javascript">        <span class="hljs-keyword">var</span> aLi = oUl.getElementsByTagName(<span class="hljs-string">&#x27;li&#x27;</span>)</span><br><span class="javascript">        <span class="hljs-keyword">var</span> num = <span class="hljs-number">4</span></span><br><span class="javascript"></span><br><span class="javascript">        <span class="hljs-comment">//事件委托，添加的子元素也有事件</span></span><br><span class="javascript">        oUl.onmouseover = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ev</span>) </span>&#123;</span><br><span class="javascript">          <span class="hljs-comment">// 兼容ie的判断</span></span><br><span class="javascript">          <span class="hljs-keyword">var</span> ev = ev || <span class="hljs-built_in">window</span>.event</span><br><span class="javascript">          <span class="hljs-keyword">var</span> target = ev.target || ev.srcElement</span><br><span class="javascript">           <span class="hljs-comment">// 获取目标节点,确定是li,添加对应style属性</span></span><br><span class="javascript">          <span class="hljs-keyword">if</span> (target.nodeName.toLowerCase() == <span class="hljs-string">&#x27;li&#x27;</span>) &#123;</span><br><span class="javascript">            target.style.background = <span class="hljs-string">&#x27;red&#x27;</span></span><br><span class="javascript">          &#125;</span><br><span class="javascript">        &#125;</span><br><span class="javascript">        oUl.onmouseout = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ev</span>) </span>&#123;</span><br><span class="javascript">          <span class="hljs-keyword">var</span> ev = ev || <span class="hljs-built_in">window</span>.event</span><br><span class="javascript">          <span class="hljs-keyword">var</span> target = ev.target || ev.srcElement</span><br><span class="javascript">          <span class="hljs-comment">// 获取目标节点,确定是li,添加对应style属性</span></span><br><span class="javascript">          <span class="hljs-keyword">if</span> (target.nodeName.toLowerCase() == <span class="hljs-string">&#x27;li&#x27;</span>) &#123;</span><br><span class="javascript">            target.style.background = <span class="hljs-string">&#x27;#fff&#x27;</span></span><br><span class="javascript">          &#125;</span><br><span class="javascript">        &#125;</span><br><span class="javascript">        <span class="hljs-comment">//添加新节点</span></span><br><span class="javascript">        oBtn.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">          num++</span><br><span class="javascript">          <span class="hljs-keyword">var</span> oLi = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;li&#x27;</span>)</span><br><span class="javascript">          oLi.innerHTML = <span class="hljs-number">111</span> * num</span><br><span class="javascript">          oUl.appendChild(oLi)</span><br><span class="javascript">        &#125;</span><br><span class="javascript">      &#125;</span><br><span class="javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h3 id="3、事件执行过程"><a href="#3、事件执行过程" class="headerlink" title="3、事件执行过程"></a><strong>3、事件执行过程</strong></h3><ul><li><p>当某个元素绑定的事件被触发时，这时浏览器就会从顶级document元素发出一个事件流</p></li><li><p>这个事件流顺着dom层级，一层一层向下找，直到遇到了触发事件的目标元素，这个查找的过程是捕获阶段</p><p> 说明：捕获阶段，在查找每一层dom时，遇到相同的事件默认不执行，元素的事件默认在冒泡阶段执行</p></li><li><p>到达目标元素后会触发目标元素绑定的事件函数，也就是目标元素事件函数处理阶段</p></li><li><p>在处理过目标元素事件后，在顺着dom层级一层一层向上查找，这时对应dom上如果有相同的事件，默认会被触发，冒泡阶段</p></li><li><p>总结: 事件触发,其实会经历<code>捕获阶段,执行阶段,冒泡阶段</code>注意: 只有两个阶段能同时执行（捕获 + 执行、或者 执行 + 冒泡 ）</p></li><li><p>补充: 捕获阶段的处理函数最先执行,其次是目标阶段的处理函数,最后是冒泡阶段的处理函数,目标阶段的处理函数,先注册的先执行,后注册的后执行</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;ie=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width:300px;height:300px;background:green;&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;firstClick()&quot;</span>&gt;</span><br>    parent<br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;child&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;secondClick()&quot;</span>&gt;</span>child<br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">onclick</span> = <span class="hljs-string">&quot;thirdClick()&quot;</span>&gt;</span>提交<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">    <span class="hljs-keyword">var</span> divs=<span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&quot;div&quot;</span>);<span class="hljs-comment">//获取所有的divs</span></span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">firstClick</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">        alert(<span class="hljs-string">&#x27;firstClick&#x27;</span>)</span><br><span class="javascript">    &#125;</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">secondClick</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">        alert(<span class="hljs-string">&#x27;secondClick&#x27;</span>)</span><br><span class="javascript">    &#125;</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">thirdClick</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">        alert(<span class="hljs-string">&#x27;thirdClick&#x27;</span>)</span><br><span class="javascript">    &#125;</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn0</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">        alert(<span class="hljs-string">&quot;box&quot;</span>);</span><br><span class="javascript">    &#125;</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">        alert(<span class="hljs-string">&quot;child&quot;</span>);</span><br><span class="javascript">    &#125;</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn2</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">        alert(<span class="hljs-string">&quot;but&quot;</span>);</span><br><span class="javascript">    &#125;</span><br><span class="javascript">    <span class="hljs-comment">//addEventListener有三个参数，最后一个参数是决定元素事件的触发阶段，默认是false，在冒泡阶段执行，设置为true,则在捕获阶段执行。</span></span><br><span class="javascript">    divs[<span class="hljs-number">0</span>].addEventListener(<span class="hljs-string">&quot;click&quot;</span>,fn0,<span class="hljs-literal">false</span>);</span><br><span class="javascript">    divs[<span class="hljs-number">1</span>].addEventListener(<span class="hljs-string">&quot;click&quot;</span>,fn1,<span class="hljs-literal">false</span>);</span><br><span class="javascript">    divs[<span class="hljs-number">2</span>].addEventListener(<span class="hljs-string">&quot;click&quot;</span>,fn2,<span class="hljs-literal">false</span>);</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="4、本地存储-localStorage和sessionStorage的区别"><a href="#4、本地存储-localStorage和sessionStorage的区别" class="headerlink" title="4、本地存储 localStorage和sessionStorage的区别"></a><strong>4、本地存储 localStorage和sessionStorage的区别</strong></h3><ul><li><strong>生命周期</strong><ul><li>localStorage<code>生命周期是永久</code>，这意味着除非用户显示在浏览器提供的UI上清除localStorage信息，否则这些信息将永远存在。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信</li><li>sessionStorage<code>仅在当前会话下有效</code>，<code>关闭页面或浏览器后被清除</code>。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。源生接口可以接受，亦可再次封装来对Object和Array有更好的支持</li></ul></li><li><strong>作用域不同</strong><ul><li>不同浏览器无法共享localStorage或sessionStorage中的信息,相同浏览器的不同页面间可以共享相同的 localStorage（页面属于相同域名和端口）</li><li>但是不同页面或标签页间无法共享sessionStorage的信息,这里需要注意的是，页面及标 签页仅指顶级窗口，如果一个标签页包含多个iframe标签且他们属于同源页面，那么他们之间是可以共享sessionStorage的</li></ul></li><li><strong>存储内容类型</strong><ul><li>localStorage和sessionStorage只能存储字符串类型，对于复杂的对象可以使用ECMAScript提供的JSON对象的stringify()和parse()来处理</li></ul></li><li><strong>应用场景区别</strong><ul><li>localStoragese：常用于长期登录（判断用户是否已登录），适合长期保存在本地的数据</li><li>sessionStorage：敏感账号一次性登录</li></ul></li></ul><h2 id="Js高级"><a href="#Js高级" class="headerlink" title="Js高级"></a>Js高级</h2><h3 id="1、谈谈你对闭包的理解"><a href="#1、谈谈你对闭包的理解" class="headerlink" title="1、谈谈你对闭包的理解"></a><strong>1、谈谈你对闭包的理解</strong></h3><ul><li><p><strong>闭包的概念</strong></p><ul><li>闭包函数就是能够读取其它函数局部变量的函数</li></ul></li><li><p><strong>理解变量作用域</strong></p><ul><li><p>首先要理解一下变量作用域,在js中无外乎分为<code>局部作用域</code>,<code>全局作用域</code>,特点是,局部作用域,可以访问全局作用域声明的变量,但是全局作用域下,无法访问局部作用域下声明的变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1- 在函数内部,可以访问全局下声明的变量</span><br><span class="hljs-keyword">var</span> n=<span class="hljs-number">999</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>)</span>&#123;<br>　　　alert(n);<br>　　&#125;<br>　f1(); <span class="hljs-comment">// 999</span><br><span class="hljs-comment">// 2- 读取函数内部的变量,是无法访问的</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>)</span>&#123;<br>　　　<span class="hljs-keyword">var</span> n=<span class="hljs-number">999</span>;<br>　　&#125;<br>　　alert(n); <span class="hljs-comment">// error</span><br><br><span class="hljs-comment">// 3- 需要注意,如果在函数内部不使用var申请变量,那么会变成一个全局的变量</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>)</span>&#123;<br>　　　 n=<span class="hljs-number">999</span>;<br>　　&#125;<br>　　alert(n); <span class="hljs-comment">// 999 </span><br><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>如何从函数外部读取局部变量</strong></p><ul><li><p>通过上述的演示,想要获取到内部变量,是无法实现的,这个时候,要想获取的话,可以在函数内部在去定义一个函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>&#123;<br>     <span class="hljs-keyword">var</span>  n = <span class="hljs-number">999</span><br>       <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span>(<span class="hljs-params"></span>) </span>&#123;<br>         alert(n) <span class="hljs-comment">// 999</span><br>       &#125;<br>     &#125;<br>     <span class="hljs-comment">/*</span><br><span class="hljs-comment">     在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1 就是不可见的。</span><br><span class="hljs-comment">     这就是Javascript语言特有的“链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。</span><br><span class="hljs-comment">     既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！</span><br><span class="hljs-comment">   */</span><br></code></pre></td></tr></table></figure></li><li><p>改写成以下方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">var</span> n = <span class="hljs-number">999</span><br>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span>(<span class="hljs-params"></span>) </span>&#123;<br>          alert(n)<br>        &#125;<br>        <span class="hljs-keyword">return</span> f2<br>      &#125;<br>      <span class="hljs-keyword">var</span> result = f1()<br>      result() <span class="hljs-comment">// 999</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>闭包函数的用途</strong></p><ul><li><p>实现公有变量(函数累加器)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-keyword">var</span> num = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-built_in">console</span>.log( ++ num);<br>&#125;<br><span class="hljs-keyword">return</span> a;<br>&#125;<br><span class="hljs-keyword">var</span> myadd = add();<br>myadd();<span class="hljs-comment">//结果为1</span><br>myadd();<span class="hljs-comment">//结果为2</span><br></code></pre></td></tr></table></figure></li><li><p>可以缓存(存储结构)</p></li><li><p>可以实现封装(私有化变量)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Deng</span>(<span class="hljs-params">name,wife</span>)</span>&#123;<br><span class="hljs-keyword">var</span> prepareWife = <span class="hljs-string">&quot;传智教育&quot;</span>;<br><span class="hljs-built_in">this</span>.name = name;<br><span class="hljs-built_in">this</span>.wife = wife;<br><span class="hljs-built_in">this</span>.divorce = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-built_in">this</span>.wife = prepareWife;<br>&#125;<br><span class="hljs-built_in">this</span>.changePrepareWife = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">target</span>)</span>&#123;<br>prepareWife = target;<br>&#125;<br><span class="hljs-built_in">this</span>.sayPrepareWife = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-built_in">console</span>.log(prepareWife);<br>&#125;<br>&#125;<br><span class="hljs-keyword">var</span> deng = <span class="hljs-keyword">new</span> Deng(<span class="hljs-string">&#x27;黑马&#x27;</span>,<span class="hljs-string">&#x27;传智&#x27;</span>);<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>闭包函数的注意事项</strong></p><ul><li>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</li><li> 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值</li></ul></li></ul><h3 id="2、谈谈你对原型、原型链的理解及如何延长作用域链？"><a href="#2、谈谈你对原型、原型链的理解及如何延长作用域链？" class="headerlink" title="2、谈谈你对原型、原型链的理解及如何延长作用域链？"></a><strong>2、谈谈你对原型、原型链的理解及如何延长作用域链？</strong></h3><ul><li><p><strong>原型</strong></p><ul><li><p>在JavaScript中,每当定义一个,函数数据类型(普通函数,类)时候,都会天生自带一个<code>prototype</code>属性,这个属性指向函数的原型对象,并且这个属性是一个对象数据类型的值</p><p><img src="https://wushuo1031.oss-cn-beijing.aliyuncs.com/img/p44.png"></p></li></ul></li><li><p><strong>原型链</strong></p><ul><li><p>每一个对象数据类型(普通的对象、实例、<code>prototype</code>……)也天生自带一个属性<code>__proto__</code>，属性值是当前实例所属类的原型(<code>prototype</code>)。原型对象中有一个属性<code>constructor</code>, 它指向函数对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br>  <span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person()<br>  <span class="hljs-built_in">console</span>.log(person.__proto__ === Person.prototype)<span class="hljs-comment">//true</span><br>  <span class="hljs-built_in">console</span>.log(Person.prototype.constructor===Person)<span class="hljs-comment">//true</span><br>  <span class="hljs-comment">//顺便学习一个ES5的方法,可以获得对象的原型</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.getPrototypeOf(person) === Person.prototype) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><img src="https://wushuo1031.oss-cn-beijing.aliyuncs.com/img/_proto_.png"></p><ul><li>创建Person函数,通过<code>prototype</code>属性,可以访问当前Person函数的原型对象</li><li>在Person函数的原型对象中,存在一个<code>constructor</code>属性(构造器),指向的就是Person函数本身</li><li>Person最终需要使用new Person()创建为一个对象,此时就称之为<code>实例对象</code>,被new出来的这个实例对象,可以通过<code>__proto__</code>访问原型对象</li><li>简述原型链: 当前实例对象访问原型对象上的方法,如何当前原型对象存在访问的方法,那么就用,否则沿着当前向上一次查找,查找到最顶级为: <code>Object.prototype</code>那么此时为访问到<code>null</code></li></ul></li></ul></li><li><p><strong>延长作用域链</strong></p><ul><li><p>在javaScript中执行环境,只有全局函数,和局部函数,但还是有其它的方式,来延长作用域,实现的原理可以在作用域的前端,加上一个<code>变量对象</code>,并且该变量在执行完毕之后会被销毁</p></li><li><p>有两种情况,可以达到这种效果</p><ul><li><p>try-catch语句的catch块: try中的代码捕获到错误以后，会把异常对象推入一个可变对象并置于作用域的头部，在catch代码块内部，函数的所有局部变量将会被放在第二个作用域对象中，catch中的代码执行完，会立即销毁当前作用域。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span><br><span class="javascript">    <span class="hljs-keyword">var</span> txt=<span class="hljs-string">&quot;&quot;</span>;</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">message</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">      <span class="hljs-keyword">try</span>&#123;</span><br><span class="javascript">             adddlert(<span class="hljs-string">&quot;Welcome guest!&quot;</span>)</span><br><span class="javascript">         &#125;</span><br><span class="javascript">      <span class="hljs-keyword">catch</span>(err)&#123;</span><br><span class="javascript">         txt=<span class="hljs-string">&quot;本页中存在错误。\n\n&quot;</span>;</span><br><span class="javascript">         txt+=<span class="hljs-string">&quot;错误描述：&quot;</span> + err.description + <span class="hljs-string">&quot;\n\n&quot;</span>;</span><br><span class="javascript">         txt+=<span class="hljs-string">&quot;点击“确定”继续。\n\n&quot;</span>;</span><br><span class="javascript">         alert(txt);</span><br><span class="javascript">       &#125;</span><br><span class="javascript">&#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;查看消息&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;message()&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>with语句: 这两个语句都会在作用域链的前端添加一个变量对象。对with语句来说，会将指定的对象添加到作用域链中。对catch语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildUrl</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> qs = <span class="hljs-string">&quot;?debug=true&quot;</span>;<br>    <span class="hljs-function"><span class="hljs-title">with</span>(<span class="hljs-params">location</span>)</span>&#123;<br>        <span class="hljs-keyword">var</span> url = href + qs;<br>    &#125;<br>    <span class="hljs-keyword">return</span> url;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>之前的作用域为</p><ul><li>window全局对象</li><li>buildUrl的变量对象</li></ul></li><li><p>加入with语句以后</p><ul><li>widndow全局对象</li><li>buildUrl的变量对象</li><li>with的loction对象</li></ul></li><li><p>with语句接收的是Location对象,因此其变量中就包含了Location对象的所有属性和方法,而这个对象被添加到了作用域链的最前端,<code>buildUrl()</code>函数中定义了一个变量<code>qs</code>,当在with语句中引用变量<code>href</code>时(实际引用的是location.href),可以在当前执行环境的变量对象中找到,当引用变量qs时,引用的则是在<code>buildUrl()</code>中定义的那个变量,而该变量的位于函数环境的变量对象中,至于with语句内部,则定义了一个名为url的变量,因而url就成了函数执行环境的一部分,所以可以作为函数的值被返回</p></li></ul></li></ul></li></ul><h3 id="3、Call和apply，bind的区别"><a href="#3、Call和apply，bind的区别" class="headerlink" title="3、Call和apply，bind的区别"></a><strong>3、Call和apply，bind的区别</strong></h3><ul><li><p><strong>基本定义</strong></p><ul><li>apply：调用一个对象的一个方法，用另一个对象替换当前对象, 例如：<code>B.apply(A, arguments);即A对象应用B对象的方法</code></li><li>call：调用一个对象的一个方法，用另一个对象替换当前对象, 例如：<code>B.call(A, args1,args2);即A对象调用B对象的方法</code></li><li>bind: 一个函数被<code>call/apply</code>的时候,会被直接调用,但是<code>bind</code>会创建一个新的函数,当这个函数被调用时,<code>bind()</code>的第一个参数将作为它运行时的<code>this</code>,之后的一序列参数,将会在传递的实参前传入作为它的参数</li></ul></li><li><p><strong>相同之处</strong></p><ul><li>都可以用来代替一个对象调用一个方法,将一个函数的对象从上下文初始的上下文,更改为<code>thisObj</code>指定的方法</li></ul></li><li><p><strong>不同之处</strong></p><ul><li>apply：最多只能有两个参数——新this对象和一个数组argArray。如果给该方法传递多个参数，则把参数都写进这个数组里面，当然，即使只有一个参数，也要写进数组里。如果argArray不是一个有效的数组或arguments对象，那么将导致一个TypeErro,如果没有提供argArray和thisObj任何一个参数，那么Global对象将被用作thisObj，并且无法被传递任何参数</li><li>call：它可以接受多个参数，第一个参数与apply一样，后面则是一串参数列表,这个方法主要用在js对象各方法相互调用的时候，使<code>当前this实例指针保持一致</code>，或者在特殊情况下需要改变this指针。如果没有提供thisObj参数，那么 Global 对象被用作thisObj</li><li>bind：会创建一个新的函数（称为绑定函数），新函数与被调函数（绑定函数的目标函数）具有相同的函数体，当目标函数被调用this值绑定到bind()的第一个参数，该参数不能被重写，绑定函数被调用时，bind()也接收预设的参数提供给原函数，一个绑定函数也能使用new操作符创建对象，这种行为相遇于把原函数当做一个构造器，提供的this值被忽略，同时调用时的参数，被提供给模拟函数</li><li>实际上，apply和call的功能是一样的，只是传入的参数列表形式不同,<code>apply只可以接收一个数组,而call可以接收多个参数</code>，<code>bind除了返回的是一个函数以外</code>，它的参数和call是一样的</li></ul></li><li><p><strong>使用场景</strong></p><ul><li><p>call</p><ul><li>实现继承</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Animal</span> (<span class="hljs-params">name</span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.showName=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name)<br>    &#125;<br>&#125; <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Cat</span>(<span class="hljs-params">name</span>)</span>&#123;<br>    Animal.call(<span class="hljs-built_in">this</span>,name)<br>&#125;<br><span class="hljs-keyword">var</span> cat = <span class="hljs-keyword">new</span> Cat(<span class="hljs-string">&#x27;Black Cat&#x27;</span>)<br>cat.showName()<br></code></pre></td></tr></table></figure><ul><li>将伪数组转化成数组</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fakeArr = &#123;<span class="hljs-number">0</span>:<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">1</span>:<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-number">2</span>:<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-number">3</span>:<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-attr">length</span>:<span class="hljs-number">2</span>&#125;<br><span class="hljs-keyword">var</span> arr1 = Arra.prototype.slice.call(fakeArr)<br><span class="hljs-built_in">console</span>.log(arr1[<span class="hljs-number">0</span>])<br><span class="hljs-keyword">var</span> arr2 = [].slice.call(fakeArr)<br><span class="hljs-built_in">console</span>.log(arr2[<span class="hljs-number">0</span>])<br>arr1.push(<span class="hljs-string">&#x27;c&#x27;</span>)<br><span class="hljs-built_in">console</span>.log(arr1)<br></code></pre></td></tr></table></figure></li><li><p>apply</p><ul><li>数组添加</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 数组添加</span><br><span class="hljs-keyword">var</span> arr1 = [<span class="hljs-number">12</span>,<span class="hljs-number">23</span>,<span class="hljs-number">5</span>]<br><span class="hljs-keyword">var</span> arr2=[<span class="hljs-string">&#x27;jack&#x27;</span>,<span class="hljs-string">&#x27;rows&#x27;</span>,<span class="hljs-string">&#x27;mac&#x27;</span>]<br><span class="hljs-built_in">Array</span>.prototype.push.apply(arr1,arr2)<br><span class="hljs-built_in">console</span>.log(arr1)<br></code></pre></td></tr></table></figure><ul><li>获取数组最大值和最小值</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> num = [<span class="hljs-number">12</span>,<span class="hljs-number">43</span>,<span class="hljs-number">5</span>,<span class="hljs-number">67</span>,<span class="hljs-number">7</span>,<span class="hljs-number">90</span>,<span class="hljs-number">6</span>]<br><span class="hljs-keyword">var</span> maxNum = <span class="hljs-built_in">Math</span>.max.apply(<span class="hljs-built_in">Math</span>,num)<br><span class="hljs-keyword">var</span> minNum = <span class="hljs-built_in">Math</span>.min.apple(<span class="hljs-built_in">Math</span>,num)<br><span class="hljs-built_in">console</span>.log(maxNum)<br><span class="hljs-built_in">console</span>.log(minNum)<br></code></pre></td></tr></table></figure></li><li><p>bind</p><ul><li>保存this变量</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> foo = &#123;<br>    <span class="hljs-attr">bar</span> : <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">eventBind</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">var</span> _this = <span class="hljs-built_in">this</span> ;<br>        $(<span class="hljs-string">&#x27;.someClass&#x27;</span>).on(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>&#123;<br>            <span class="hljs-built_in">console</span>.log(_this.bar);     <br>        &#125;);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> foo = &#123;<br>    <span class="hljs-attr">bar</span> : <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">eventBind</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        $(<span class="hljs-string">&#x27;.someClass&#x27;</span>).on(<span class="hljs-string">&#x27;click&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>&#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.bar);      <br>        &#125;.bind(<span class="hljs-built_in">this</span>));<br>    &#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="4、常见的js中的继承方法有哪些"><a href="#4、常见的js中的继承方法有哪些" class="headerlink" title="4、常见的js中的继承方法有哪些"></a>4、<strong>常见的js中的继承方法有哪些</strong></h3><ul><li><p><strong>4-1 原型链继承方式</strong></p><ul><li><strong>重点:</strong></li><li>让实例的原型等于父类的实例</li><li><strong>特点:</strong><ul><li>实例可以继承属性,实例的构造函数属性,父类构造函数属性,父类原型属性(新实例不会继承父类实例的属性)</li></ul></li><li><strong>缺点:</strong><ul><li>新实例无法向父类构造函数传参</li><li>继承较为单一化</li><li>有新实例都会共享父类实例属性(原型上的属性都是共享的)</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//    1- 使用原型链实现继承</span><br>   <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name</span>)</span>&#123;<br>       <span class="hljs-built_in">this</span>.name = name||<span class="hljs-string">&#x27;Person&#x27;</span><br>       <span class="hljs-built_in">this</span>.sleep=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>           <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;my is Person eat&#x27;</span>)<br>       &#125;<br>   &#125;<br>Person.prototype.eat=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;my is Person prototype &#x27;</span>)<br>&#125;<br><span class="hljs-comment">// 2- 创建子类实现继承</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Cat</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br>student.prototype=<span class="hljs-keyword">new</span> Person()<br><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Student()<br><span class="hljs-built_in">console</span>.log(p.name)<br></code></pre></td></tr></table></figure></li><li><p><strong>4-2  构造函数继承方式</strong></p><ul><li><strong>重点:</strong></li><li>使用call()和apply()方法,将父类构造函数引入子类构造函数(在子类函数中做了父类函数的自执行)</li><li><strong>特点:</strong><ul><li>只继承了父类的属性,但是没有继承父类原型的属性</li><li>解决了原型继承中的1,2,3点缺陷</li><li>可以继承多个构造函数属性(call多个)</li><li>可以在子实例中向父级实例传参</li></ul></li><li><strong>缺点:</strong></li><li>只能继承父类构造函数的属性<ul><li>无法实现构造函数复用(每次复用都要重新调用)</li><li>每个新实例都有父类构造函数的副本</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Cat</span>(<span class="hljs-params">name</span>) </span>&#123;<br>   Animal.call(<span class="hljs-built_in">this</span>)<br>   <span class="hljs-built_in">this</span>.name = name || <span class="hljs-string">&#x27;jack&#x27;</span><br> &#125;<br><span class="hljs-comment">// Test Code</span><br> <span class="hljs-keyword">var</span> cat = <span class="hljs-keyword">new</span> Cat()<br> <span class="hljs-built_in">console</span>.log(cat.name)<br> <span class="hljs-built_in">console</span>.log(cat.sleep())<br> <span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Animal) <span class="hljs-comment">// false</span><br> <span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Cat) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li><li><p><strong>4-3 组合继承方式</strong></p><ul><li><strong>重点:</strong><ul><li>结合原型继承/构造函数的优点,传参和复用</li></ul></li><li><strong>特点:</strong><ul><li>可以继承父类原型上的属性,可以传参,复用</li><li>每个新实例引入的构造函数属性,都是私有的</li></ul></li><li><strong>缺点:</strong><ul><li>调用了两次父类构造函数(消耗内存)</li><li>子类的构造函数会代替原型上那个父类构造函数</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Cat</span>(<span class="hljs-params">name</span>)</span>&#123;<br> Animal.call(<span class="hljs-built_in">this</span>,name)<br>&#125;<br>Animal.prototype=<span class="hljs-keyword">new</span> Animal()<br><span class="hljs-comment">// Test Code</span><br><span class="hljs-keyword">var</span> cat = <span class="hljs-keyword">new</span> Cat();<br><span class="hljs-built_in">console</span>.log(cat.name);<br><span class="hljs-built_in">console</span>.log(cat.sleep());<br><span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Animal); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Cat); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li><li><p><strong>4-4 实例继承方式</strong></p><ul><li><strong>重点:</strong></li><li>为父类实例添加新特性,作为子类返回</li><li><strong>特点:</strong> <ul><li>不限调用方式,不管new()还是子类()返回的对象都有相同的效果</li></ul></li><li><strong>缺点:</strong><ul><li>实例是父类的实例,不是子类的实例</li><li>不支持多继承</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Cat</span>(<span class="hljs-params">name</span>)</span>&#123;<br>  <span class="hljs-keyword">var</span> instance= <span class="hljs-keyword">new</span> Animal()<br>  instance.name=name||<span class="hljs-string">&#x27;jack&#x27;</span><br>   <span class="hljs-keyword">return</span> instance<br>&#125;<br><span class="hljs-comment">// Test Code</span><br><span class="hljs-keyword">var</span> cat = Cat(anm)<br><span class="hljs-built_in">console</span>.log(cat.name);<br><span class="hljs-built_in">console</span>.log(cat.sleep());<br><span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Animal); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Cat); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure></li><li><p><strong>4-5 拷贝继承方式</strong></p><ul><li><strong>重点:</strong><ul><li>使用for in 循环的方式,把父类进行循环</li></ul></li><li><strong>特点:</strong><ul><li>支持多继承的方式</li></ul></li><li><strong>缺点:</strong><ul><li>效率较低,内存占用高(拷贝父类的属性/方法)</li><li>无法获取父类不可枚举的方法</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Cat</span>(<span class="hljs-params">name</span>)</span>&#123;<br>  <span class="hljs-keyword">var</span> animal = <span class="hljs-keyword">new</span> Animal();<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> p <span class="hljs-keyword">in</span> animal)&#123;<br>    Cat.prototype[p] = animal[p];<br>  &#125;<br>  <span class="hljs-built_in">this</span>.name = name || <span class="hljs-string">&#x27;Tom&#x27;</span>;<br>&#125;<br><br><span class="hljs-comment">// Test Code</span><br><span class="hljs-keyword">var</span> cat = <span class="hljs-keyword">new</span> Cat();<br><span class="hljs-built_in">console</span>.log(cat.name);<br><span class="hljs-built_in">console</span>.log(cat.sleep());<br><span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Animal); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Cat); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li><li><p><strong>4-6 寄生组合继承方式</strong></p><ul><li><strong>重点:</strong></li><li>其实就是用一个新的构造函数,当做一个中转,来实现的继承</li><li><strong>特点:</strong><ul><li>结合了构造继承以及原型继承的方式实现的</li></ul></li></ul></li><li><p><strong>缺点:</strong></p><ul><li>实现过程较为复杂</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Cat</span>(<span class="hljs-params">name</span>)</span>&#123;<br>  Animal.call(<span class="hljs-built_in">this</span>);<br>  <span class="hljs-built_in">this</span>.name = name || <span class="hljs-string">&#x27;Tom&#x27;</span>;<br>&#125;<br>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-comment">// 创建一个没有实例方法的类</span><br>  <span class="hljs-keyword">var</span> Super = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;;<br>  Super.prototype = Animal.prototype;<br>  <span class="hljs-comment">//将实例作为子类的原型</span><br>  Cat.prototype = <span class="hljs-keyword">new</span> Super();<br>&#125;)();<br><br><span class="hljs-comment">// Test Code</span><br><span class="hljs-keyword">var</span> cat = <span class="hljs-keyword">new</span> Cat();<br><span class="hljs-built_in">console</span>.log(cat.name);<br><span class="hljs-built_in">console</span>.log(cat.sleep());<br><span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Animal); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Cat); <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="5、this指向"><a href="#5、this指向" class="headerlink" title="5、this指向"></a><strong>5、this指向</strong></h3><ul><li><p>this关键字,在调用之前无法确定,只有在最终调用时,才会确定最终的指向,但是主要出现的场景有以下几种</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1- 普通函数</span><br>      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>) <span class="hljs-comment">// window  严格模式下,指向的是,undefined</span><br>      &#125;<br>      f1()<br><br>      <span class="hljs-comment">// 2- 在定时器中</span><br>      <span class="hljs-built_in">setTimeout</span>(<br>        (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>          <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>) <span class="hljs-comment">// window</span><br>        &#125;)(),<br>        <span class="hljs-number">1000</span><br>      )<br><br>      <span class="hljs-comment">// 3- 在事件中</span><br>      <span class="hljs-keyword">var</span> btn = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#btn&#x27;</span>)<br>      btn.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>) <span class="hljs-comment">// 指向事件源</span><br>      &#125;<br><br>      <span class="hljs-comment">// 4- 在对象的属性中</span><br>      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name, age</span>) </span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name<br>        <span class="hljs-built_in">this</span>.age = age<br>        <span class="hljs-built_in">this</span>.sayHi = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>          <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">var</span> NewPerson = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;jack&#x27;</span>, <span class="hljs-number">20</span>)<br>      <span class="hljs-built_in">console</span>.log(NewPerson.name) <span class="hljs-comment">// 指向的是实例对象</span><br><br>      <span class="hljs-comment">// 5- 在对象的方法中</span><br>      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">PersonHi</span>(<span class="hljs-params">name, age</span>) </span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name<br>        <span class="hljs-built_in">this</span>.age = age<br>        <span class="hljs-built_in">this</span>.sayHi = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>          <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">var</span> NewPersonHi = <span class="hljs-keyword">new</span> PersonHi(<span class="hljs-string">&#x27;jack&#x27;</span>, <span class="hljs-number">20</span>)<br>      <span class="hljs-built_in">console</span>.log(NewPersonHi.sayHi()) <span class="hljs-comment">// 指向的是,当前方法的对象</span><br><br>      <span class="hljs-comment">// 6- 在箭头函数中的this</span><br>      <span class="hljs-keyword">let</span> obj = &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;jack&#x27;</span>,<br>        <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>,<br>        <span class="hljs-attr">sayHi</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>          <span class="hljs-keyword">var</span> sayHiOne = <span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name + <span class="hljs-built_in">this</span>.age) <span class="hljs-comment">// 指向的是,当前上级的对象</span><br>          &#125;<br>          <span class="hljs-keyword">return</span> sayHiOne()<br>        &#125;,<br>      &#125;<br>      <span class="hljs-built_in">console</span>.log(obj.sayHi())<br><br>      <span class="hljs-comment">// 7- 补充: 当this遇到return的时候</span><br>      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_thisReturn</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;jack&#x27;</span><br>        <span class="hljs-keyword">return</span> &#123;&#125; <span class="hljs-comment">// 一个空的对象,那么this指向返回的那个对象,</span><br>      &#125;<br>      <span class="hljs-keyword">let</span> newObj = <span class="hljs-keyword">new</span> _thisReturn()<br>      <span class="hljs-built_in">console</span>.log(newObj.name) <span class="hljs-comment">// undefined</span><br><br>      <span class="hljs-comment">// 如果声明的一个null类型,那么指向还是最后的实例对象</span><br>      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_thisReturn</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;jack&#x27;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>      &#125;<br>      <span class="hljs-keyword">let</span> newObj = <span class="hljs-keyword">new</span> _thisReturn()<br>      <span class="hljs-built_in">console</span>.log(newObj.name) <span class="hljs-comment">// jack  </span><br><br>     <span class="hljs-comment">// 如果声明的是一个undefined的话,那么指向还是最后的实例对象</span><br>      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_thisReturn</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;jack&#x27;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span><br>      &#125;<br>      <span class="hljs-keyword">let</span> newObj = <span class="hljs-keyword">new</span> _thisReturn()<br>      <span class="hljs-built_in">console</span>.log(newObj.name) <span class="hljs-comment">// jack</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="6、深拷贝和浅拷贝的区别（拓展需要掌握）"><a href="#6、深拷贝和浅拷贝的区别（拓展需要掌握）" class="headerlink" title="6、深拷贝和浅拷贝的区别（拓展需要掌握）"></a><strong>6、深拷贝和浅拷贝的区别（拓展需要掌握）</strong></h3><ul><li><p><strong>基本定义</strong></p><ul><li>浅拷贝<ul><li>创建一个新的数据，这个数据有着原始数据属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址，所以如果其中一个数据改变了这个地址，就会影响到另一个数据</li></ul></li><li>深拷贝<ul><li>深拷贝会拷贝所有的属性，并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。在堆中重新分配内存，拥有不同的地址，且值是一样的，复制后的对象与原来的对象是完全隔离，互不影响。</li></ul></li></ul></li><li><p><strong>示例介绍</strong></p><ul><li><strong>浅拷贝</strong>(浅拷贝只会将<code>对象的各个属性</code>进行复制，并不会进行递归复制，而JavaScript存储对象是存地址的，所以浅复制会导致Obj.arr和shallowObj.arr指向同一块内存地址)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">var</span> b = a;<br>a[<span class="hljs-number">0</span>] = <span class="hljs-number">2</span><br><span class="hljs-built_in">console</span>.log(a);<br><span class="hljs-built_in">console</span>.log(b);<br><br><span class="hljs-comment">//因为b浅拷贝a, ab指向同一个内存地址(堆内存中存的值)</span><br><span class="hljs-comment">//b会随着a的变化而变化</span><br><span class="hljs-comment">//[2, 2, 3, 4, 5]</span><br><span class="hljs-comment">//[2, 2, 3, 4, 5]</span><br><br>******************分割线********************<br><span class="hljs-comment">//此递归方法不包含数组对象</span><br><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">a</span>:<span class="hljs-number">1</span>, <span class="hljs-attr">arr</span>: [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] &#125;;<br><span class="hljs-keyword">var</span> shallowObj = shallowCopy(obj);<br> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shallowCopy</span>(<span class="hljs-params">src</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> newobj = &#123;&#125;;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> prop <span class="hljs-keyword">in</span> src) &#123;<br>      <span class="hljs-keyword">if</span> (src.hasOwnProperty(prop)) &#123;<br>        newobj[prop] = src[prop];<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newobj;<br>  &#125;<br>  shallowObj.arr[<span class="hljs-number">1</span>] = <span class="hljs-number">5</span>;<br>  <span class="hljs-built_in">console</span>.log(obj.arr[<span class="hljs-number">1</span>]);     <span class="hljs-comment">//5</span><br>  <br></code></pre></td></tr></table></figure></li><li><p><strong>深拷贝</strong>(深拷贝则不同，它不仅将原对象的各个属性逐个复制出去，而且将原对象各个属性所<code>包含的对象</code>也依次采用深复制的方法递归复制到新对象上,这就不会存在obj和shallowObj的arr属性指向同一个对象的问题)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123; <br>     <span class="hljs-attr">a</span>:<span class="hljs-number">1</span>, <br>     <span class="hljs-attr">arr</span>: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]，<br>     <span class="hljs-attr">nation</span> : <span class="hljs-string">&#x27;中国&#x27;</span>,<br>     <span class="hljs-attr">birthplaces</span>:[<span class="hljs-string">&#x27;北京&#x27;</span>,<span class="hljs-string">&#x27;上海&#x27;</span>,<span class="hljs-string">&#x27;广州&#x27;</span>]<br> &#125;;<br> <span class="hljs-keyword">var</span> obj2 = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;杨&#x27;</span>&#125;;<br> obj2 = deepCopy(obj,obj2);<br> <span class="hljs-built_in">console</span>.log(obj2);<br> <span class="hljs-comment">//深复制，要想达到深复制就需要用递归</span><br> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepCopy</span>(<span class="hljs-params">o, c</span>)</span>&#123;<br>       <span class="hljs-keyword">var</span> c = c || &#123;&#125;;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> o)&#123;<br>           <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> o[i] === <span class="hljs-string">&#x27;object&#x27;</span>)&#123;<br>                <span class="hljs-keyword">if</span>(o[i].constructor === <span class="hljs-built_in">Array</span>)&#123;<br>                     <span class="hljs-comment">//这是数组</span><br>                     c[i] = [];<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                     <span class="hljs-comment">//这是对象</span><br>                     c[i] = &#123;&#125;;<br>                &#125;<br>                deepCopy(o[i], c[i]);<br>           &#125;<span class="hljs-keyword">else</span>&#123;<br>                c[i] = o[i];<br>           &#125;  <br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br> &#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="7、js如何处理防抖和节流（很重要）"><a href="#7、js如何处理防抖和节流（很重要）" class="headerlink" title="7、js如何处理防抖和节流（很重要）"></a><strong>7、js如何处理防抖和节流（很重要）</strong></h3><ul><li><p><strong>基本定义</strong></p><ul><li>防抖函数/节流函数,都是为了限制函数的执行频次，以优化函数触发频率过高导致的响应速度跟不上触发频率，出现延迟，假死或卡顿的现象</li></ul></li><li><p><strong>防抖函数</strong></p><ul><li><p>当持续的触发一个事件时(resize，scoll，mousemove，mouseover)一定时间内再没有触发该事件,事件处理函数才会执行一次,如果设定的时间到来之前,又触发了一次,那么就需要延时触发,<code>触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/* </span><br><span class="hljs-comment">      1. 防抖: 实现方式：每次触发事件时设置一个延迟调用方法，并且取消之前的延时调用方法</span><br><span class="hljs-comment">        缺点：如果事件在规定的时间间隔内被不断的触发，则调用方法会被不断的延迟</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn, delay</span>) </span>&#123;<br>      <span class="hljs-comment">// 创建一个标记来存放定时器的返回值</span><br>      <span class="hljs-keyword">var</span> timeout = <span class="hljs-literal">null</span>;<br>      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;<br>        <span class="hljs-comment">// 每当用户操作时,把之前的计时器清零</span><br>　　　　<span class="hljs-keyword">if</span>(timeout !== <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-built_in">clearTimeout</span>(timeout);<br>        &#125;<br><span class="hljs-comment">// 然后又创建一个新的 setTimeout, 这样就能保证interval 间隔内如果时间持续触发，就不会执 行 fn 函数</span><br>        timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>          fn.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);<br>        &#125;, delay)<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// 处理函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handle</span>(<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;防抖：&#x27;</span>, <span class="hljs-built_in">Math</span>.random());<br>    &#125;<br>    <span class="hljs-comment">//点击事件</span><br>    <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, debounce(handle, <span class="hljs-number">500</span>));<br></code></pre></td></tr></table></figure></li><li><p><strong>实现原理:</strong> <code>将多次操作合并为一次操作进行。原理是维护一个计时器，规定在delay时间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。</code></p></li></ul></li><li><p>节流函数</p><ul><li><p>节流函数,<code>高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率</code>,比如重复调用ajax请求,不仅会造成请求混乱,并且还有造成网络堵塞,占用服务器带宽,节流函数使用一次性定时器实现的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 时间戳</span><br>    <span class="hljs-keyword">var</span> throttle = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">func, delay</span>) </span>&#123;<br>      <span class="hljs-keyword">var</span> prev = <span class="hljs-built_in">Date</span>.now();<br>      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">var</span> context = <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">arguments</span>;<br>        <span class="hljs-keyword">var</span> now = <span class="hljs-built_in">Date</span>.now();<br>        <span class="hljs-keyword">if</span> (now - prev &gt;= delay) &#123;<br>          func.apply(context, args);<br>          prev = <span class="hljs-built_in">Date</span>.now();<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">//定时器</span><br>    <span class="hljs-comment">// 节流throttle代码（定时器）：</span><br><span class="hljs-keyword">var</span> throttle = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">func, delay</span>) </span>&#123;<br>      <span class="hljs-keyword">var</span> timer = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">var</span> context = <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">arguments</span>;<br>        <span class="hljs-keyword">if</span> (!timer) &#123;<br>          timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>            func.apply(context, args);<br>            timer = <span class="hljs-literal">null</span>;<br>          &#125;, delay);<br>        &#125;<br>      &#125;<br>    &#125;<span class="hljs-comment">// 节流函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn, delay</span>) </span>&#123;<br>        <span class="hljs-keyword">let</span> flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) </span>&#123;<br>            <span class="hljs-keyword">if</span> (!flag) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            flag = <span class="hljs-literal">false</span>;<br>            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>                fn(...args)<br>                flag = <span class="hljs-literal">true</span>;<br>            &#125;, delay);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>实现原理:</strong> <code>使得一定时间内只触发一次函数,原理是通过判断是否有延迟调用函数未执行</code>,函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据, 这样的场景，就适合用节流技术来实现。</p></li></ul></li></ul><h3 id="8、如何延长作用域链？"><a href="#8、如何延长作用域链？" class="headerlink" title="8、如何延长作用域链？"></a><strong>8、如何延长作用域链？</strong></h3><ul><li><p>在javaScript中执行环境,只有全局函数,和局部函数,但还是有其它的方式,来延长作用域,实现的原理可以在作用域的前端,加上一个<code>变量对象</code>,并且该变量在执行完毕之后会被销毁</p></li><li><p>有两种情况,可以达到这种效果</p><ul><li><p>with语句: 这两个语句都会在作用域链的前端添加一个变量对象。对with语句来说，会将指定的对象添加到作用域链中。对catch语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildUrl</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> qs = <span class="hljs-string">&quot;?debug=true&quot;</span>;<br>    <span class="hljs-function"><span class="hljs-title">with</span>(<span class="hljs-params">location</span>)</span>&#123;<br>        <span class="hljs-keyword">var</span> url = href + qs;<br>    &#125;<br>    <span class="hljs-keyword">return</span> url;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>try-catch语句的catch块: try中的代码捕获到错误以后，会把异常对象推入一个可变对象并置于作用域的头部，在catch代码块内部，函数的所有局部变量将会被放在第二个作用域对象中，catch中的代码执行完，会立即销毁当前作用域。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;html&gt;<br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">var</span> txt=<span class="hljs-string">&quot;&quot;</span>;</span></span><br><span class="javascript"><span class="xml">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">message</span>(<span class="hljs-params"></span>)</span>&#123;</span></span><br><span class="javascript"><span class="xml">      <span class="hljs-keyword">try</span>&#123;</span></span><br><span class="javascript"><span class="xml">             adddlert(<span class="hljs-string">&quot;Welcome guest!&quot;</span>)</span></span><br><span class="javascript"><span class="xml">         &#125;</span></span><br><span class="javascript"><span class="xml">      <span class="hljs-keyword">catch</span>(err)&#123;</span></span><br><span class="javascript"><span class="xml">         txt=<span class="hljs-string">&quot;本页中存在错误。\n\n&quot;</span>;</span></span><br><span class="javascript"><span class="xml">         txt+=<span class="hljs-string">&quot;错误描述：&quot;</span> + err.description + <span class="hljs-string">&quot;\n\n&quot;</span>;</span></span><br><span class="javascript"><span class="xml">         txt+=<span class="hljs-string">&quot;点击“确定”继续。\n\n&quot;</span>;</span></span><br><span class="javascript"><span class="xml">         alert(txt);</span></span><br><span class="javascript"><span class="xml">       &#125;</span></span><br><span class="javascript"><span class="xml">&#125;</span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;查看消息&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;message()&quot;</span> /&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br>&lt;/html&gt;<br><br></code></pre></td></tr></table></figure><ul><li><p>之前的作用域为:</p><ul><li>window全局对象</li><li>buildUrl的变量对象</li></ul></li><li><p>加入with语句以后</p><ul><li>widndow全局对象</li><li>buildUrl的变量对象</li><li>with的loction对象</li></ul></li><li><p>with语句接收的是location对象,因此其变量中就包含了location对象的所有属性和方法,而这个对象被添加到了作用域链的最前端,<code>buildUrl()</code>函数中定义了一个变量<code>qs</code>,当在with语句中引用变量<code>href</code>时(实际引用的是location.href),可以在当前执行环境的变量对象中找到,当引用变量qs时,引用的则是在<code>buildUrl()</code>中定义的那个变量,而该变量的位于函数环境的变量对象中,至于with语句内部,则定义了一个名为url的变量,因而url就成了函数执行环境的一部分,所以可以作为函数的值被返回</p></li></ul></li></ul></li></ul><h3 id="9、super的作用-如何使用"><a href="#9、super的作用-如何使用" class="headerlink" title="9、super的作用 如何使用"></a><strong>9、super的作用 如何使用</strong></h3><ul><li><p><strong>基本定义:</strong></p><ul><li>this指向当前函数所在的当前对象</li><li>super指向当前对象所在的原型对象</li></ul></li><li><p><strong>使用区别:</strong></p><ul><li>super()当做函数使用时<ul><li>当做函数时,<code>super()</code>代表是父类构造函数,所以要求,必须执行一次</li><li>当做函数时,只能在子类构造函数中使用,否则会报错</li></ul></li><li>super()当做对象使用时<ul><li>在普通方法中,指向父类的原型对象</li><li>在静态方法<code>(static)</code>中,指向父类</li><li>由于对象总是继承与其它对象,所以在任意对象中也可以使用super关键字</li></ul></li></ul></li><li><p><strong>super()当做函数使用时</strong></p><ul><li><p><code>super</code>关键字,既可以当做函数使用,也可以当做对象使用,在这两种情况下,使用方法完全不同</p></li><li><p>1- <code>super</code>当做函数调用时,代表父类的构造函数,es6中要求,子类的构造函数必须要执行一次<code>super()</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;&#125;<br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-title">extendes</span> <span class="hljs-title">A</span> </span>&#123;<br>      <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>          <span class="hljs-built_in">super</span>() <span class="hljs-comment">// 必须执行一次super(),否则会报错</span><br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure></li><li><p>以下代码中<code>super</code>方法,虽然代表了父类A的构造函数,但是返回的确是子类B的实例,<code>super</code>内部的this指向的还是,B的实例,因为在这里<code>super()</code>相当于<code>A.prototype.constructor.call(this)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span>.target.name);<br>  &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>();<br>  &#125;<br>&#125;<br><span class="hljs-keyword">new</span> A() <span class="hljs-comment">// A</span><br><span class="hljs-keyword">new</span> B() <span class="hljs-comment">// B</span><br></code></pre></td></tr></table></figure></li><li><p>2- 作为函数时，<code>super()</code>只能用在子类的构造函数之中，用在其他地方就会报错</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">m</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>(); <span class="hljs-comment">// 报错</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>super()当做对象使用时</strong></p><ul><li><p>1-<code>super</code>作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">p</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>();<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">super</span>.p()); <span class="hljs-comment">// 2</span><br>  &#125;<br>&#125;<br><span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> B();<br><span class="hljs-comment">// 上面代码中，子类B当中的super.p()，就是将super当作一个对象使用。这时，super在普通方法之中，指向A.prototype，所以super.p()就相当于A.prototype.p()。</span><br></code></pre></td></tr></table></figure></li><li><p>2- 这里需要注意，由于<code>super</code>指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过<code>super</code>调用的,但是定义在原型上就可以获取到</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>          <span class="hljs-built_in">this</span>.a = <span class="hljs-number">20</span><br>        &#125;<br>      &#125;<br>      <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;<br>        get m () &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.a<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> B()<br>      <span class="hljs-built_in">console</span>.log(b.m) <span class="hljs-comment">// undefined</span><br><br><span class="hljs-comment">// &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;***************分割线***************&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span><br>           <span class="hljs-comment">// 定义在原型上</span><br>      <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;&#125;<br>      A.prototype.x= <span class="hljs-number">20</span><br>      <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;<br>        get m () &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.x<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> B()<br>      <span class="hljs-built_in">console</span>.log(b.m) <span class="hljs-comment">// 20</span><br></code></pre></td></tr></table></figure></li><li><p>3- ES6 规定，在子类普通方法中通过<code>super</code>调用父类的方法时，方法内部的<code>this</code>指向当前的子类实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>       <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>         <span class="hljs-built_in">this</span>.x = <span class="hljs-number">1</span><br>       &#125;<br>       <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-params"></span>)</span> &#123;<br>         <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.x)<br>       &#125;<br>     &#125;<br>    <br>     <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;<br>       <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>         <span class="hljs-built_in">super</span>()<br>         <span class="hljs-built_in">this</span>.x = <span class="hljs-number">2</span><br>       &#125;<br>       <span class="hljs-function"><span class="hljs-title">m</span>(<span class="hljs-params"></span>)</span> &#123;<br>         <span class="hljs-built_in">super</span>.print()<br>       &#125;<br>     &#125;<br>     <span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> B()<br>     b.m() <span class="hljs-comment">// 2</span><br>     <span class="hljs-comment">//上面代码中，super.print()虽然调用的是A.prototype.print()，但是A.prototype.print()内部的this指向子类B的实例，导致输出的是2，而不是1。也就是说，实际上执行的是super.print.call(this)。</span><br></code></pre></td></tr></table></figure></li><li><p>4- 如果<code>super</code>作为对象，用在静态方法之中，这时<code>super</code>将指向父类，而不是父类的原型对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> </span>&#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">myMethod</span>(<span class="hljs-params">msg</span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;static&#x27;</span>, msg);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">myMethod</span>(<span class="hljs-params">msg</span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;instance&#x27;</span>, msg);<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Parent</span> </span>&#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">myMethod</span>(<span class="hljs-params">msg</span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>.myMethod(msg);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">myMethod</span>(<span class="hljs-params">msg</span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>.myMethod(msg);<br>  &#125;<br>&#125;<br><br>Child.myMethod(<span class="hljs-number">1</span>); <span class="hljs-comment">// static 1</span><br><br><span class="hljs-keyword">var</span> child = <span class="hljs-keyword">new</span> Child();<br>child.myMethod(<span class="hljs-number">2</span>); <span class="hljs-comment">// instance 2</span><br><br><span class="hljs-comment">// 上面代码中，super在静态方法之中指向父类，在普通方法之中指向父类的原型对象</span><br></code></pre></td></tr></table></figure></li><li><p>5- 在子类的静态方法中通过<code>super</code>调用父类的方法时，方法内部的<code>this</code>指向当前的子类，而不是子类的实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.x = <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.x);<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>();<br>    <span class="hljs-built_in">this</span>.x = <span class="hljs-number">2</span>;<br>  &#125;<br>  <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-title">m</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>.print();<br>  &#125;<br>&#125;<br><br>B.x = <span class="hljs-number">3</span>;<br>B.m() <span class="hljs-comment">// 3</span><br><span class="hljs-comment">// 上面代码中，静态方法B.m里面，super.print指向父类的静态方法。这个方法里面的this指向的是B，而不是B的实例。</span><br></code></pre></td></tr></table></figure></li><li><p>6- 使用<code>super</code>的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>();<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">super</span>); <span class="hljs-comment">// 报错</span><br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//console.log(super)当中的super，无法看出是作为函数使用，还是作为对象使用，所以 JavaScript 引擎解析代码的时候就会报错。这时，如果能清晰地表明super的数据类型，就不会报错。</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>();<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">super</span>.valueOf() <span class="hljs-keyword">instanceof</span> B); <span class="hljs-comment">// true</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> B();<br></code></pre></td></tr></table></figure></li><li><p>7- 由于对象可以继承对象,所以在任意对象中都可以使用super()方法,实现继承</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-function"><span class="hljs-title">toString</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;MyObject: &quot;</span> + <span class="hljs-built_in">super</span>.toString();<br>  &#125;<br>&#125;;<br><br>obj.toString(); <span class="hljs-comment">// MyObject: [object Object]</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><h3 id="1、Ajax的原理是什么"><a href="#1、Ajax的原理是什么" class="headerlink" title="1、Ajax的原理是什么"></a><strong>1、Ajax的原理是什么</strong></h3><ul><li><p><strong>实现原理:</strong></p><ul><li>其核心是 XMLHttpRequest对象</li><li>IE浏览器使用ActiveXObject</li></ul></li><li><p><strong>常用属性:</strong></p><ul><li><p>onreadystatechange属性</p><ul><li><p>存有服务器响应的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">xhr.onreadystatechange=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-comment">// 可以在这里做些操作</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>readyState属性</p><ul><li><p>存储服务器响应的状态信息,每当readyState改变时,onreadystatechange函数就会被执行,readyState属性可能有的值</p><img src="https://wushuo1031.oss-cn-beijing.aliyuncs.com/img/readyState.png" style="zoom:150%;" /></li><li><p>向这个onreadystatechange函数中添加一个判断语句,测试响应是否成功</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">xhr.onreadystatechange=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>      <span class="hljs-comment">// 可以在这里做些操作</span><br>      <span class="hljs-keyword">if</span>(xhr.readyState===<span class="hljs-number">4</span>)&#123;<br>          <span class="hljs-comment">// 从服务的response获得数据</span><br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>responseText</p><ul><li><p>可以通过responseText属性来获取服务器返回的数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">xhr.onreadystatechange=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-comment">// 可以在这里做些操作</span><br>    <span class="hljs-keyword">if</span>(xhr.readyState===<span class="hljs-number">4</span>)&#123;<br>        <span class="hljs-comment">// 从服务的response获得数据</span><br>        <span class="hljs-built_in">document</span>.myForm.time.value= xhr.reponseText<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>其它属性</p><p>​    <img src="https://wushuo1031.oss-cn-beijing.aliyuncs.com/img/%E5%85%B6%E5%AE%83%E5%B1%9E%E6%80%A7.png"></p></li></ul></li><li><p><strong>常用方法:</strong></p><ul><li><p>open()方法</p><ul><li>open()有三个参数,<code>第一个参数定义发送请求使用的方法</code>第二个参数<code>规定服务器端脚本的URL,</code>,第三个参数<code>规定应对当前请求进行异步处理</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">xhr.opne(<span class="hljs-string">&#x27;GET&#x27;</span>,test.php,<span class="hljs-literal">true</span>) <span class="hljs-comment">// ture代表异步</span><br></code></pre></td></tr></table></figure></li><li><p>send()方法</p><ul><li>send()方法将请求发送服务器,假设HTML文件,和PHP文件位于相同目录,那么代码是以下形式</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">xhr.send(<span class="hljs-literal">null</span>)<br></code></pre></td></tr></table></figure></li><li><p>其它方法<img src="https://wushuo1031.oss-cn-beijing.aliyuncs.com/img/%E5%85%B6%E5%AE%83%E6%96%B9%E6%B3%958.png"></p></li></ul></li><li><p><strong>发送一个ajax-get请求</strong></p><ul><li>创建XMLHttpRequest对象</li><li>设置请求方式</li><li>调用回调函数</li><li>发送请求</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1- 创建对象</span><br><span class="hljs-keyword">let</span> xhr =<span class="hljs-keyword">new</span>  XMLHttpRequest()<br><span class="hljs-keyword">var</span> url = <span class="hljs-string">`http://location:8080/ajaxGet/login`</span><br><span class="hljs-comment">// 2- 设置请求参数</span><br>xhr.opne(<span class="hljs-string">&#x27;GET&#x27;</span>,url,<span class="hljs-literal">true</span>)<br><span class="hljs-comment">// 3- 发送请求</span><br>xhr.send()<br><span class="hljs-comment">// 4- 注册事件</span><br>xhr.onreadystatechange=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">if</span>(xhr.readyState===<span class="hljs-number">4</span> &amp;&amp; xhr.status===<span class="hljs-number">200</span>)&#123; <br>            <span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;id&#x27;</span>)<br>            obj.innerHTML= xml.responseText <br>    &#125; <span class="hljs-keyword">else</span>&#123;<br>            alert(<span class="hljs-string">&#x27;ajax服务器返回错误&#x27;</span>)<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>发送一个ajax-post请求</strong></p><ul><li>发送post请求,需要添加上请求头,否则会报错</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1- 创建对象</span><br><span class="hljs-keyword">let</span> xhr =<span class="hljs-keyword">new</span>  XMLHttpRequest()<br><span class="hljs-keyword">var</span> url = <span class="hljs-string">`http://location:8080/ajaxGet/login`</span><br><span class="hljs-comment">//2- post请求一定要添加请求头才行不然会报错</span><br>xhr.setRequestHeader(<span class="hljs-string">&quot;Content-type&quot;</span>,<span class="hljs-string">&quot;application/x-www-form-urlencoded&quot;</span>);<br><span class="hljs-comment">// 3- 设置请求参数</span><br>xhr.open(<span class="hljs-string">&#x27;PSOT&#x27;</span>,url,<span class="hljs-literal">true</span>)<br><span class="hljs-comment">// 4- 发送请求</span><br>xhr.send()<br><span class="hljs-comment">// 5- 注册事件</span><br>xhr.onreadystatechange=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">if</span>(xhr.readyState===<span class="hljs-number">4</span> &amp;&amp; xhr.status === <span class="hljs-number">200</span>)&#123;<br>            <span class="hljs-comment">// 响应成功,做些什么</span><br>            <span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;id&#x27;</span>)<br>            obj.innerHTML= xml.responseText <br>    &#125;  <span class="hljs-keyword">else</span>&#123;<br>            alert(<span class="hljs-string">&#x27;ajax服务器返回错误&#x27;</span>)<br>        &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><h3 id="2、Get和post请求方式的区别有哪些"><a href="#2、Get和post请求方式的区别有哪些" class="headerlink" title="2、Get和post请求方式的区别有哪些"></a><strong>2、Get和post请求方式的区别有哪些</strong></h3><ul><li>用处<ul><li>get常用于获取,post用于提交数据</li></ul></li><li>安全性<ul><li>get比post<code>相对安全</code></li><li>get直接把参数暴露在Url地址栏后,post是把请求参数放到请求体中,get参数直接暴露,浏览器会缓存,如果把密码和用户名缓存,那么就会造成泄漏,导致不安全</li></ul></li><li>请求参数<ul><li>querystring是url的一部分,get,post都可以带上,get的querystring(仅支持urlencode编码),post参数,是放在Body(支持多种编码)</li></ul></li><li>请求参数长度限制<ul><li>get请求长度最多1024kb,post请求对数据没有限制</li><li>在http规范中,并没有对get请求方式进行大小限制,但是浏览器不同,对url长度有限制,对于Post理论上不受限制的</li></ul></li><li>TCP数据包<ul><li>get请求会产生一个TCP数据包,post请求会产生两个TCP数据包</li></ul></li></ul><h3 id="3、请解释一下-JavaScript-的同源策略"><a href="#3、请解释一下-JavaScript-的同源策略" class="headerlink" title="3、请解释一下 JavaScript 的同源策略"></a><strong>3、请解释一下 JavaScript 的同源策略</strong></h3><ul><li><p><strong>含义</strong></p><ul><li><p>同源策略指的是,一下三者必须要统一,一者不同,就产生跨域</p><ul><li><p>域名</p></li><li><p>协议</p></li><li><p>端口</p><p> <img src="https://wushuo1031.oss-cn-beijing.aliyuncs.com/img/%E8%B7%A8%E5%9F%9F.png"></p></li></ul></li></ul></li><li><p><strong>目的</strong></p><ul><li>同源策略,为了保证用户信息安全,防止恶意网站窃取数据,假设用户在A网站登录,然后去其它网站浏览,但是B网站,可以获取A网站的cookie,那么此时就会造成用户信息泄露</li></ul></li><li><p><strong>限制</strong></p><ul><li>cookie,LocalStorage和indexDB无法获取</li><li>DOM无法获得</li><li>Ajax请求不能发送</li></ul></li><li><p><strong>规避限制</strong></p><ul><li>cookie<ul><li>cookie是服务器写入浏览器的一段信息,只有同源的网页才能共享,但是两个网页一级域名相同,只是二级域名不同,浏览器允许设置<code>document.domain</code>共享cookie信息</li><li>两个网页不同源: 无法获取对方的DOM,使用<code>Iframe</code>和<code>window.opne</code>方法打开窗口</li></ul></li><li>LocalStorage<ul><li>通过postMessage()方法,允许跨窗口通信,无论是否两个是不是同源,该方法两个参数,参数1具体信息内容,参数2接收窗口的源(协议+域名+端口)也可以设置为* 表示不受限制,向所有窗口发送</li></ul></li><li>ajax<ul><li>jsonp</li><li>cors</li></ul></li></ul></li></ul><h3 id="4、解决跨域的方式有哪些"><a href="#4、解决跨域的方式有哪些" class="headerlink" title="4、解决跨域的方式有哪些"></a><strong>4、解决跨域的方式有哪些</strong></h3><ul><li><p><strong>jsonp</strong></p><ul><li><p>基本定义</p><ul><li>通过添加一个script元素,向服务器请求json数据,这种做法不受同源策略限制,利用的是script中的src属性,服务器收到请求以后,将数据放到一个指定名字的回调函数中,传递回来</li></ul></li><li><p>具体实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;script&#x27;</span>);<br>script.setAttribute(<span class="hljs-string">&quot;type&quot;</span>,<span class="hljs-string">&quot;text/javascript&quot;</span>);<br>script.src = src;<br><span class="hljs-built_in">document</span>.body.appendChild(script);<br>&#125;<br><span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  addScriptTag(<span class="hljs-string">&#x27;http://example.com/ip?callback=foo&#x27;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">data</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Your public IP address is: &#x27;</span> + data.ip);<br>    <br> <span class="hljs-comment">//=============________服务器端代码</span><br><span class="hljs-comment">// 服务器收到请求后,会把数据放到这个函数的参数位置上    </span><br>foo(&#123;<br>  <span class="hljs-string">&quot;ip&quot;</span>: <span class="hljs-string">&quot;8.8.8.8&quot;</span><br>&#125;);<br><br></code></pre></td></tr></table></figure></li></ul></li><li><p>缺点</p><ul><li>只能发送Get的请求方式,无法处理Post请求方式</li><li>只支持跨域HTTP请求的清空,不能解决不同域的两个页面之间进行js调用的问题</li><li>jsonp在调用失败的时候,不会返回http状态码</li><li>存在一定的安全漏洞</li></ul></li><li><p><strong>Cors</strong></p><ul><li><p>基本定义</p><ul><li>Cors是一个wc3认定的一个标准,跨域资源共享（Cross-origin resource sharing）解决了ajax只能同源使用的限制</li><li>目前浏览器和服务器都支持该种方式,浏览器版本不能低于IE10</li></ul></li><li><p>实现方式(Cors分为简单请求和复杂请求)</p><ul><li><p><strong>简单请求方式,只要满足一下两大条件就可以</strong></p><p><img src="https://wushuo1031.oss-cn-beijing.aliyuncs.com/img/Cors1.png"></p></li><li><p>简单请求,只需要添加一个<code>origin</code>字段即可,浏览器发现是一个简单请求,就自动会在请求头中添加一个<code>origin</code>字段</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">GET /cors HTTP/<span class="hljs-number">1.1</span><br><span class="hljs-comment">// origin字段用来说明,本次请求,来自哪个源(协议+域名+端口) 服务器根据这个值,决定是否同意这次请求</span><br><span class="hljs-attr">Origin</span>: http:<span class="hljs-comment">//api.bob.com</span><br>Host: api.alice.com<br>Accept-Language: en-US<br><span class="hljs-attr">Connection</span>: keep-alive<br>User-Agent: Mozilla/<span class="hljs-number">5.0</span>...<br></code></pre></td></tr></table></figure></li><li><p>如果<code>origin</code>指定的源,不在许可范围内,服务器会返回一个正常的HTTP回应,浏览器发现这个回应头信息没有包含<code>Access-Control-Allow-Origin</code>字段,会抛出一个错误,被<code>XMLHttpRequest</code>的<code>onerror</code>回调函数捕获,这种错误,是无法通过状态码识别的,如果<code>Origin</code>指定的域名在许可范围内,服务器会返回响应,多出几个头信息字段</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">Access-Control-Allow-Origin: http:<span class="hljs-comment">//api.bob.com</span><br>Access-Control-Allow-Credentials: <span class="hljs-literal">true</span><br>Access-Control-Expose-Headers: FooBar<br>Content-Type: text/html; charset=utf-<span class="hljs-number">8</span><br><span class="hljs-comment">// 该请求头中,有三个与Cors请求相关的字段,都按照Access-Contronl开头</span><br></code></pre></td></tr></table></figure></li><li><p>Access-Contronl-Allow-Origin</p><ul><li>该字段是必须的,它的值要么是请求时<code>origin</code>字段,要么是一个<code>*</code>,表示接受任意域名的请求,如果发送cookie,<code>Access-Contronl-Allow-Origin</code>不能设置为星号,必须指定明确的,与请求网页一致的域名,同时cookie依然遵循同源政策,只有服务器域名设置的cookie才会上传,其它域名的cookie并不会上传,且(跨域)原网页代码中的<code>document.cookie</code>也无法读取服务器域名下的cookie信息</li></ul></li><li><p>Access-Control-Allow-Credentials</p><ul><li>该字段是一个可选字段,表示是否允许发送Cookie,默认情况下,Cookir不包含在Cors的请求之中,true代表服务器明确许可,Cookie可以包含在请求中,是一个单选项,如果不设置true,那么删除该字段即可</li></ul></li><li><p>Access-Control-Ecpose-Headers</p><ul><li>该字段可选。CORS请求时，<code>XMLHttpRequest</code>对象的<code>getResponseHeader()</code>方法只能拿到6个基本字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。如果想拿到其他字段，就必须在<code>Access-Control-Expose-Headers</code>里面指定。上面的例子指定，<code>getResponseHeader(&#39;FooBar&#39;)</code>可以返回<code>FooBar</code>字段的值</li></ul></li><li><p>withCredentials属性</p><ul><li><p>Cors默认是不会发送Cookie信息,和http认证信息,如果要报Cookie发送到服务器,一方面要服务器统一,指定<code>Access-Control-Allow-Credentials</code>字段</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">Access-Control-Allow-Credentials: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li><li><p>另一方面,开发者必须在Ajax请求中打开<code>withCredentials</code>属性,否则即使服务器统一发送cookie,浏览器也不会进行发送,如何省略<code>withCredentials</code>字段,有的浏览器还是会发送cookie信息,这个时候,可以显示的关闭<code>xhr.withCredentials = false;</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest()<br>xhr.withCredentials= <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>非简单请求</strong></p><ul><li><p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是<code>PUT</code>或<code>DELETE</code>，或者<code>Content-Type</code>字段的类型是<code>application/json</code>,非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）,浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段,只有得到肯定答复，浏览器才会发出正式的<code>XMLHttpRequest</code>请求，否则就报错</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> url = <span class="hljs-string">&#x27;http://api.alice.com/cors&#x27;</span>;<br><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<br>xhr.open(<span class="hljs-string">&#x27;PUT&#x27;</span>, url, <span class="hljs-literal">true</span>);<br>xhr.setRequestHeader(<span class="hljs-string">&#x27;X-Custom-Header&#x27;</span>, <span class="hljs-string">&#x27;value&#x27;</span>);<br>xhr.send();<br></code></pre></td></tr></table></figure></li><li><p>上面代码中,HTTP的请求方式,是一个PUT,并且发送一个自定义头信息X-Custom-Header,就自动发出一个”预检”请求，要求服务器确认可以这样请求。下面是这个”预检”请求的HTTP头信息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">OPTIONS /cors HTTP/<span class="hljs-number">1.1</span><br><span class="hljs-attr">Origin</span>: http:<span class="hljs-comment">//api.bob.com</span><br>Access-Control-Request-Method: PUT<br>Access-Control-Request-Headers: X-Custom-Header<br><span class="hljs-attr">Host</span>: api.alice.com<br>Accept-Language: en-US<br><span class="hljs-attr">Connection</span>: keep-alive<br>User-Agent: Mozilla/<span class="hljs-number">5.0</span>...<br></code></pre></td></tr></table></figure></li><li><p>“预检”请求用的请求方法是<code>OPTIONS</code>，表示这个请求是用来询问的。头信息里面，关键字段是<code>Origin</code>，表示请求来自哪个源,除了<code>Origin</code>字段,”预检”请求头中的信息包含两个特殊的字段</p></li><li><p>Access-Control-Request-Method</p><ul><li>该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是<code>PUT</code>。</li></ul></li><li><p>Access-Control-Request-Headers</p><ul><li>该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是<code>X-Custom-Header</code></li></ul></li><li><p>服务器通过了预检请求,每个浏览器都正常的CORS请求,就跟每个简单的请求一样,会产生一个<code>Origin</code>字段,服务器也会回应一个<code>Access-Control-Allow-Origin</code>头信息字段</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 预检 请求之后,浏览器的正常Cors请求, Origin字段的信息,是自动添加的</span><br>PUT /cors HTTP/<span class="hljs-number">1.1</span><br><span class="hljs-attr">Origin</span>: http:<span class="hljs-comment">//api.bob.com</span><br>Host: api.alice.com<br>X-Custom-Header: value<br>Accept-Language: en-US<br><span class="hljs-attr">Connection</span>: keep-alive<br>User-Agent: Mozilla/<span class="hljs-number">5.0</span>...<br></code></pre></td></tr></table></figure></li><li><p>服务器的正常反应(‘Access-Control-Allow-Origin’该字段每次回应都是必须包含的)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">Access-Control-Allow-Origin: http:<span class="hljs-comment">//api.bob.com</span><br>Content-Type: text/html; charset=utf-<span class="hljs-number">8</span><br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li></ul><h3 id="5、什么是同步什么是异步"><a href="#5、什么是同步什么是异步" class="headerlink" title="5、什么是同步什么是异步"></a><strong>5、什么是同步什么是异步</strong></h3><ul><li><p><strong>单线程</strong></p><ul><li><p>JavaScript是一门单线程语言,因此，<code>JavaScript在同一个时间只能做一件事，单线程意味着，如果在同个时间有多个任务的话，这些任务就需要进行排队，前一个任务执行完，才会执行下一个任务</code>，因为javaScript是一个单线程执行过程,同时间内处理多个任务,所有任务都会排队,前一个任务执行完毕,下一个任务才会执行,如果上一个任务执行时间很长(比如ajax请求),那么就会造成下一个任务等待,严重影响用户体验,所以才会有<code>同步任务</code>和<code>异步任务</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 同步代码</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun2</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);<br>&#125;<br>fun1();<br>fun2();<br><span class="hljs-comment">// 输出</span><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-comment">// 如果fun1中是一个ajax操作,需要一定的时间,那么我们需要完全等待fun1()执行完毕后,才能执行fun2()吗?</span><br></code></pre></td></tr></table></figure><p><img src="https://wushuo1031.oss-cn-beijing.aliyuncs.com/img/%E5%90%8C%E6%AD%A5&%E5%BC%82%E6%AD%A5.png"></p></li></ul></li><li><p><strong>同步任务</strong></p><ul><li><p>同步任务是指,<code>主线程上排队执行的任务,只有前一个任务执行完毕,才能继续执行下一个任务</code>,当我们打开网站时,网站的渲染过程,比如元素的渲染,就是一个同步任务</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 同步代码</span><br><span class="hljs-keyword">var</span> num = <span class="hljs-number">20</span>;<br><span class="hljs-built_in">console</span>.log(num) <span class="hljs-comment">// 马上输出结果</span><br><br><span class="hljs-comment">// 同步代码</span><br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">12</span>,<span class="hljs-number">3224</span>,<span class="hljs-number">34</span>]<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i =<span class="hljs-number">0</span>; i&lt;arr.length;i++)&#123;<br>    <span class="hljs-built_in">console</span>.log(arr[i])<br>&#125;<br><span class="hljs-comment">// 同步代码.........还有非常多,除了callback() ajax和setTimeout以及Proimse中的.then()方法,都可以视为同步代码</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>异步任务</strong></p><ul><li><p>异步任务是指, <code>不进入主线程,而是进入任务队列的任务,只有任务队列通知主线程,某个异步任务可以执行了,该任务才会进入主线程</code>,当我们打开网站时,例如图片的加载,音乐的加载,就是一个异步任务</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun2</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun3</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>);<br>&#125;<br>fun1();<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>  fun2();<br>&#125;,<span class="hljs-number">0</span>);<br>fun3();<br> <br><span class="hljs-comment">// 输出</span><br><span class="hljs-number">1</span><br><span class="hljs-number">3</span><br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure></li><li><p>异步机制实现原理(EventLoop是一码事)</p><ul><li>javaScript中的异步如何实现的,需要知道<code>回调和事件循环</code>,异步任务是不会进入主线程中,会先进入到<code>异步任务队列</code>,任务队列其实就是一个遵循<code>先进后出,后进先出</code>的数据结构,也是一个事件队列,例如文件读取操作,是一个异步任务,该任务会先被添加到<code>异步任务队列中</code>,等到IO完成,就会在任务队列中,<code>添加一个事件</code>,表示异步任务已经完毕,可以进入执行栈了,但是此时,主线程未必有空处理,当主线程处理完其它任务后,才会读取<code>异步任务队列</code>中的代码,单线程从任务队列中获取任务,这个过程是不断循环的,每次执行栈清空以后,都会在<code>任务队列</code>中读取,如果没有任务,等到有新任务,如果存在任务,那么就会拿出来进行执行,这个循环的过程,就叫<code>事件循环</code></li><li>总结来说<ul><li>所有同步任务都在主线程上执行，行成一个执行栈</li><li>主线程之外，还存在一个任务队列，只要异步任务有了结果，就会在任务队列中放置一个事件</li><li>一旦执行栈中所有异步任务执行完毕,系统就会读取任务队列,查看是否还存在异步任务,结束等待状态,进入执行栈,开始执行</li><li>主线程不断重复以上三步</li></ul></li></ul></li></ul></li></ul><h3 id="6、什么是HTTP协议-HTTP和HTTPS的区别（拓展需要掌握）"><a href="#6、什么是HTTP协议-HTTP和HTTPS的区别（拓展需要掌握）" class="headerlink" title="6、什么是HTTP协议  HTTP和HTTPS的区别（拓展需要掌握）"></a><strong>6、什么是HTTP协议  HTTP和HTTPS的区别（拓展需要掌握）</strong></h3><ul><li><strong>什么是HTTP协议</strong><ul><li>超文本传输协议（英文：<strong>H</strong>yper<strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网的数据通信的基础</li><li>HHTTP是一个客户端终端（用户）和服务器端（网站）请求和应答的标准（TCP）。通过使用网页浏览器、网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口（默认端口为80)我们称这个客户端为用户代理程序（user agent）。应答的服务器上存储着一些资源，比如HTML文件和图像。我们称这个应答服务器为源服务器（origin server）。在用户代理和源服务器中间可能存在多个“中间层”，比如代理服务器、网关或者隧道（tunnel）</li><li>HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如”HTTP/1.1 200 OK”，以及返回的内容，如请求的文件、错误消息、或者其它信息</li></ul></li><li><strong>HTTP和HTTPS的区别</strong><ul><li>HTTP协议传输的数据都是未加密的,明文显示,因为使用HTTP传输的隐私信息,非常的不安全,为了保证信息能够加密进行传输,所以在HTTP基础上设计了SSL(Secure Sokets Layer)协议用于HTTP协议传输的数据进行加密处理,从而就诞生了HTTPS</li><li>HTTPS协议是有SSL+HTTP协议构建的可进行加密传输,身份认证的网络协议,比HTTP协议要安全</li><li>区别如下<ul><li>HTTPS协议需要到CA申请证书,一般免费证书较少,需要一定费用</li><li>HTTP是超文本传输协议,信息是明文显示,但是HTTPS具有安全性的SSL协议加密传输</li><li>HTTP和HTTPS使用完全不同的连接方式,默认端口也不一样,前者是80后者是443</li><li>HTTP的连接也很简单,是无状态的,HHTPS协议是有SSL+HTTP协议构建可进行加密传输,以身份认证的网络协议,比HTTP协议,更加安全</li></ul></li></ul></li></ul><h3 id="7、常见的HTTP状态码有哪些，分别代表什么含义"><a href="#7、常见的HTTP状态码有哪些，分别代表什么含义" class="headerlink" title="7、常见的HTTP状态码有哪些，分别代表什么含义"></a><strong>7、常见的HTTP状态码有哪些，分别代表什么含义</strong></h3><ul><li><p><strong>状态码种类</strong></p><ul><li>1xx：指示信息–表示请求已接收，继续处理</li><li>2xx：成功–表示请求已被成功接收、理解、接受</li><li>3xx：重定向–要完成请求必须进行更进一步的操作</li><li>4xx：客户端错误–请求有语法错误或请求无法实现</li><li>5xx：服务器端错误–服务器未能实现合法的请求</li></ul></li><li><p><strong>常见状态码及含义</strong></p>   <figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tex">200 OK                        //客户端请求成功<br>400 Bad Request             //客户端请求有语法错误，不能被服务器所理解<br>401 Unauthorized            //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 <br>403 Forbidden                 //服务器收到请求，但是拒绝提供服务<br>404 Not Found                //请求资源不存在，eg：输入了错误的URL<br>500 Internal Server Error  //服务器发生不可预期的错误<br>503 Server Unavailable     //服务器当前不能处理客户端的请求，一段时间后可能恢复正常<br></code></pre></td></tr></table></figure></li></ul><h3 id="8、什么是TCP连接的三次握手（拓展需要掌握）"><a href="#8、什么是TCP连接的三次握手（拓展需要掌握）" class="headerlink" title="8、什么是TCP连接的三次握手（拓展需要掌握）"></a><a href="https://blog.csdn.net/weixin_44262932/article/details/112786892"><strong>8、什么是TCP连接的三次握手（拓展需要掌握）</strong></a></h3><ul><li>第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers)</li><li>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态</li><li>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手</li></ul><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><h3 id="1、Array拓展"><a href="#1、Array拓展" class="headerlink" title="1、Array拓展"></a>1、Array拓展</h3><ul><li>扩展运算符</li><li>Arrar.from()</li><li>Arrar.of()</li><li>实例copyWithin()</li><li>实例find()和findIndex()</li><li>实例fill()</li><li>实例entrens()keys()values()</li><li>实例inculecs()</li><li>实例flat(),flatMap()</li></ul><h3 id="2、String拓展-amp-方法"><a href="#2、String拓展-amp-方法" class="headerlink" title="2、String拓展&amp;方法"></a>2、String拓展&amp;方法</h3><ul><li><p>for of遍历</p><ul><li><p>可以使用下方的语法,进行遍历,同时,for of 可以遍历<code>oxFFF</code>的码点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> codeString <span class="hljs-keyword">of</span>  <span class="hljs-string">&#x27;foo&#x27;</span>)&#123;<br>    <span class="hljs-built_in">console</span>.log(codeString)<br>&#125;<br><span class="hljs-comment">// &quot;f&quot;</span><br><span class="hljs-comment">// &quot;o&quot;</span><br><span class="hljs-comment">// &quot;o&quot;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>模板字符串(template string)</p><ul><li><p>是一种增强版本的字符串,使用反引号(` )进行标识,可以当做普通的字符串使用,也可以定义多个字符串,同时也可以在字符串中嵌入变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&#x27;#result&#x27;</span>).append(<span class="hljs-string">`</span><br><span class="hljs-string">  There are &lt;b&gt;<span class="hljs-subst">$&#123;basket.count&#125;</span>&lt;/b&gt; items</span><br><span class="hljs-string">   in your basket, &lt;em&gt;<span class="hljs-subst">$&#123;basket.onSale&#125;</span>&lt;/em&gt;</span><br><span class="hljs-string">  are on sale!</span><br><span class="hljs-string">`</span>);<br></code></pre></td></tr></table></figure></li></ul></li><li><p>includes()</p><ul><li><p>返回一个布尔值,表示是否找到了参数字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> s = <span class="hljs-string">&#x27;Hello world!&#x27;</span>;<br>s.includes(<span class="hljs-string">&#x27;o&#x27;</span>) <span class="hljs-comment">// true</span><br><span class="hljs-comment">// 第二个参数,代表查询起始位置</span><br>s.includes(<span class="hljs-string">&#x27;o&#x27;</span>,<span class="hljs-number">6</span>) <span class="hljs-comment">// false</span><br><br></code></pre></td></tr></table></figure></li></ul></li><li><p>startsWith()</p><ul><li><p>返回布尔值,表示参数字符串是否在原字符串头部</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> s = <span class="hljs-string">&#x27;Hello Word!&#x27;</span>;<br>s.startsWith(<span class="hljs-string">&#x27;Hello&#x27;</span>) <span class="hljs-comment">// true</span><br><span class="hljs-comment">// 第二个参数,代表查询起始位置</span><br>s.endsWith(<span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-number">5</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>endsWith()</p><ul><li><p>返回布尔值,表示参数字符串是否在原字符串的尾部</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> s = <span class="hljs-string">&#x27;Hello world!&#x27;</span>;<br><span class="hljs-comment">// 第二个参数,针对前n个参数,其它两个方法,针对的是从第n个位置知道字符结束</span><br>s.startsWith(<span class="hljs-string">&#x27;world&#x27;</span>, <span class="hljs-number">6</span>) <span class="hljs-comment">// true</span><br>s.endsWith(<span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-number">5</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>repeat()</p><ul><li><p>返回新的字符串,表示将原字符串重复多少次</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">&#x27;x&#x27;</span>.repeat(<span class="hljs-number">3</span>) <span class="hljs-comment">// &quot;xxx&quot;</span><br><span class="hljs-string">&#x27;hello&#x27;</span>.repeat(<span class="hljs-number">2</span>)<span class="hljs-comment">// &quot;hellohello&quot;</span><br><br><span class="hljs-comment">// 参数如果是小数,会被取整</span><br><span class="hljs-string">&#x27;na&#x27;</span>.repeat(<span class="hljs-number">2.9</span>) <span class="hljs-comment">// &quot;nana&quot;</span><br><br><span class="hljs-comment">// 如果repeat的参数是负数,或lfinity,会报错</span><br><span class="hljs-string">&#x27;na&#x27;</span>.repeat(<span class="hljs-literal">Infinity</span>)<br><span class="hljs-comment">// RangeError</span><br><span class="hljs-string">&#x27;na&#x27;</span>.repeat(-<span class="hljs-number">1</span>)<br><span class="hljs-comment">// RangeError</span><br><br><span class="hljs-comment">// 但是，如果参数是 0 到-1 之间的小数，则等同于 0，这是因为会先进行取整运算。0 到-1 之间的小数，取整以后等于-0，repeat视同为 0</span><br><span class="hljs-string">&#x27;na&#x27;</span>.repeat(-<span class="hljs-number">0.9</span>) <span class="hljs-comment">// &quot;&quot;</span><br><br><span class="hljs-comment">// 参数是NaN等于与0</span><br><span class="hljs-string">&#x27;na&#x27;</span>.repeat(<span class="hljs-literal">NaN</span>) <span class="hljs-comment">// &quot;&quot;</span><br><br><span class="hljs-comment">// 如果repeat的参数是字符串，则会先转换成数字</span><br><span class="hljs-string">&#x27;na&#x27;</span>.repeat(<span class="hljs-string">&#x27;na&#x27;</span>) <span class="hljs-comment">// &quot;&quot;</span><br><span class="hljs-string">&#x27;na&#x27;</span>.repeat(<span class="hljs-string">&#x27;3&#x27;</span>) <span class="hljs-comment">// &quot;nanana&quot;</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3、Obejct拓展-amp-方法"><a href="#3、Obejct拓展-amp-方法" class="headerlink" title="3、Obejct拓展&amp;方法"></a>3、Obejct拓展&amp;方法</h3><ul><li><p>属性和方法简写</p><ul><li><p>属性简写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = <span class="hljs-string">&#x27;is object&#x27;</span>;<br><span class="hljs-keyword">let</span> objName = &#123;obj&#125;<br>objName <span class="hljs-comment">// &#123;obj:&#x27;is object&#x27;&#125;</span><br><br><span class="hljs-comment">// 等价于</span><br><span class="hljs-keyword">const</span> objName = &#123;<span class="hljs-attr">obj</span>:obj&#125;<br><span class="hljs-comment">//  ***********************************************分割线*****************************************</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span> (<span class="hljs-params">x,y</span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> &#123;x+y&#125;<br>&#125;<br><span class="hljs-comment">// 等同于</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span> (<span class="hljs-params">x,y</span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">x</span>:x,<span class="hljs-attr">y</span>:y&#125;<br>&#125;<br>fn(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>) <span class="hljs-comment">// Object &#123;x:1,x:2&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>方法简写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> Person=&#123;<br>    <span class="hljs-function"><span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我是Person对象中的sayHi方法&#x27;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 等价于</span><br><span class="hljs-keyword">const</span> Person=&#123;<br>    <span class="hljs-attr">sayHi</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我是Person对象中的sayHi方法&#x27;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-comment">//  ***********************************************分割线*****************************************</span><br><span class="hljs-keyword">let</span> url = <span class="hljs-string">&#x27;htpps://www.baidu.com&#x27;</span><br><span class="hljs-keyword">const</span> ToUrl =&#123;<br>    url, <br>    <span class="hljs-attr">erros</span>: ()&#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;url is errors&#x27;</span>)&#125;<br>&#125;<br><br><span class="hljs-comment">//等价于</span><br><span class="hljs-keyword">let</span> url = <span class="hljs-string">&#x27;htpps://www.baidu.com&#x27;</span><br><span class="hljs-keyword">const</span> ToUrl =&#123;<br>     <span class="hljs-comment">// 等同于: url:url</span><br>    url,<br>    <span class="hljs-comment">// 等价于:  erros:function() &#123;&#125;</span><br>    <span class="hljs-attr">erros</span>:  ()&#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;url is errors&#x27;</span>)&#125; <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>应用场景1(<code>commonJS中就可以采用这种方式</code>)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> ms = &#123;&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getItem</span> (<span class="hljs-params">key</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> key <span class="hljs-keyword">in</span> ms ? ms[key] : <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setItem</span> (<span class="hljs-params">key, value</span>) </span>&#123;<br>  ms[key] = value;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clear</span> (<span class="hljs-params"></span>) </span>&#123;<br>  ms = &#123;&#125;;<br>&#125;<br><br><span class="hljs-built_in">module</span>.exports = &#123; getItem, setItem, clear &#125;;<br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-attr">getItem</span>: getItem,<br>  <span class="hljs-attr">setItem</span>: setItem,<br>  <span class="hljs-attr">clear</span>: clear<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>应用场景2(<code>属性赋值器(getter)和属性取值期(setter)也可以采用此种方式</code>)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> cart = &#123;<br>  <span class="hljs-attr">_wheels</span>: <span class="hljs-number">4</span>,<br><br>  get wheels () &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._wheels;<br>  &#125;,<br><br>  set wheels (value) &#123;<br>    <span class="hljs-keyword">if</span> (value &lt; <span class="hljs-built_in">this</span>._wheels) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;数值太小了！&#x27;</span>);<br>    &#125;<br>    <span class="hljs-built_in">this</span>._wheels = value;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>注意事项(<code>不能在构造函数中使用简写的方式</code>)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-function"><span class="hljs-title">f</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.foo = <span class="hljs-string">&#x27;bar&#x27;</span>;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">new</span> obj.f() <span class="hljs-comment">// 报错</span><br><span class="hljs-comment">// 因为f简写的是对象的方法,所以foo.f不能当做构造函数使用</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>属性可枚举型</p><ul><li><p>对象的每个属性都有一个描述对象,用来控制该属性的行为,obj.geyOwnPropertyDescriptor方法,可以获取该属性的描述对象,描述对象的eumerable属性,称为可枚举性,如果该属性为false,就表示某些操作会忽略当前属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123; <span class="hljs-attr">foo</span> : <span class="hljs-number">123</span>&#125;<br><span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="hljs-string">&#x27;foo&#x27;</span>)<br><span class="hljs-comment">//  &#123;</span><br><span class="hljs-comment">//    value: 123,</span><br><span class="hljs-comment">//    writable: true,</span><br><span class="hljs-comment">//    enumerable: true,</span><br><span class="hljs-comment">//    configurable: true</span><br><span class="hljs-comment">//  &#125;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>属性的遍历</p><ul><li>for in<ul><li><code>for...in</code>循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）</li></ul></li><li>Object.keys<ul><li><code>Object.keys</code>返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名</li></ul></li><li>Object.getOwnPropertyNames(obj)<ul><li><code>Object.getOwnPropertyNames</code>返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名</li></ul></li><li>Object.getOwnPropertySymbols(obj)<ul><li><code>Object.getOwnPropertySymbols</code>返回一个数组，包含对象自身的所有 Symbol 属性的键名</li></ul></li><li>Reflect.ownKeys(obj)<ul><li><code>Reflect.ownKeys</code>返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举</li></ul></li><li>注意事项:<ul><li>以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则</li><li>首先遍历所有数值键，按照数值升序排列</li><li>其次遍历所有字符串键，按照加入时间升序排列</li><li>最后遍历所有 Symbol 键，按照加入时间升序排列</li></ul></li></ul></li><li><p>对象的拓展运算符</p><ul><li><p>对象的拓展运算符,用于取出参数对象的所有可遍历属性,拷贝到当前对象之中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123; <span class="hljs-attr">a</span>: &#123; <span class="hljs-attr">b</span>: <span class="hljs-number">1</span> &#125; &#125;;<br><span class="hljs-keyword">let</span> &#123; ...x &#125; = obj;<br>obj.a.b = <span class="hljs-number">2</span>;<br>x.a.b <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure></li><li><p>由于数组是特殊的对象,所以对象的拓展运算符,也可以用于数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> foo = &#123;...[<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>]&#125;<br>foo<br><span class="hljs-comment">//  &#123;0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>如果拓展运算符后面是一个空对象,那么不会有任何效果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;...&#123;&#125;, <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>&#125;<br><span class="hljs-comment">// &#123; a: 1 &#125;</span><br></code></pre></td></tr></table></figure></li><li><p>如果拓展运算符后面不是一个对象,那么会自动转换为对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 等同于 &#123;...Object(1)&#125;</span><br>&#123;..<span class="hljs-number">.1</span>&#125; <span class="hljs-comment">// &#123;&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>上面代码中,拓展运算符后面都是整数1,会自动转换为数值类型,由于该对象没有该属性,所以最后返回一个空对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 等同于 &#123;...Object(true)&#125;</span><br>&#123;...true&#125; <span class="hljs-comment">// &#123;&#125;</span><br><br><span class="hljs-comment">// 等同于 &#123;...Object(undefined)&#125;</span><br>&#123;...undefined&#125; <span class="hljs-comment">// &#123;&#125;</span><br><br><span class="hljs-comment">// 等同于 &#123;...Object(null)&#125;</span><br>&#123;...null&#125; <span class="hljs-comment">// &#123;&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>如果运算符后面是一个字符串,会自动转换为一个类数组的对象,因此返回的不是一个空对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;...<span class="hljs-string">&#x27;hello&#x27;</span>&#125;<br><span class="hljs-comment">// &#123;0: &quot;h&quot;, 1: &quot;e&quot;, 2: &quot;l&quot;, 3: &quot;l&quot;, 4: &quot;o&quot;&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>对象的拓展运算符等同于使用<code>Object.assign()</code>方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> aClone = &#123; ...a &#125;;<br><span class="hljs-comment">// 等同于</span><br><span class="hljs-keyword">let</span> aClone = <span class="hljs-built_in">Object</span>.assign(&#123;&#125;, a);<br><span class="hljs-comment">// 上面只是拷贝了对象实例的属性,如果想完整的克隆一个对象,还拷贝对象的原型属性,可以采用以下方式</span><br><span class="hljs-comment">// 写法一</span><br><span class="hljs-keyword">const</span> clone1 = &#123;<br>  <span class="hljs-attr">__proto__</span>: <span class="hljs-built_in">Object</span>.getPrototypeOf(obj),<br>  ...obj<br>&#125;;<br><br><span class="hljs-comment">// 写法二</span><br><span class="hljs-keyword">const</span> clone2 = <span class="hljs-built_in">Object</span>.assign(<br>  <span class="hljs-built_in">Object</span>.create(<span class="hljs-built_in">Object</span>.getPrototypeOf(obj)),<br>  obj<br>);<br><br><span class="hljs-comment">// 写法三</span><br><span class="hljs-keyword">const</span> clone3 = <span class="hljs-built_in">Object</span>.create(<br>  <span class="hljs-built_in">Object</span>.getPrototypeOf(obj),<br>  <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors(obj)<br>)<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="4、解构赋值"><a href="#4、解构赋值" class="headerlink" title="4、解构赋值"></a>4、解构赋值</h3><ul><li><p>对象的解构赋值</p><ul><li><p>对象的解构赋值用于从一个对象取值,相当于将目标对象自身的所有可以遍历,但尚未被读取的属性,分配到指定的对象上面,所有的键和他们的值,都会被拷贝到新对象上面</p></li><li><p>无法对<code>undefined</code>和<code>null</code>进行转换,因为这两个无法转换为对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> &#123; ...z &#125; = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 运行时错误</span><br><span class="hljs-keyword">let</span> &#123; ...z &#125; = <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// 运行时错误</span><br></code></pre></td></tr></table></figure></li><li><p>解构赋值必须是最后一个参数，否则会报错</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-keyword">let</span>&#123; ...x, y, z &#125; = someObject; <span class="hljs-comment">// 句法错误</span><br><span class="hljs-keyword">let</span> &#123; x, ...y, ...z &#125; = someObject; <span class="hljs-comment">// 句法错误</span><br></code></pre></td></tr></table></figure></li><li><p>解构赋值中的拷贝是浅拷贝</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> obj = &#123; <span class="hljs-attr">a</span>: &#123; <span class="hljs-attr">b</span>: <span class="hljs-number">1</span> &#125; &#125;;<br><span class="hljs-keyword">let</span> &#123; ...x &#125; = obj;<br>obj.a.b = <span class="hljs-number">2</span>;<br>x.a.b <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="5、Set和Map数据结构"><a href="#5、Set和Map数据结构" class="headerlink" title="5、Set和Map数据结构"></a>5、Set和Map数据结构</h3><ul><li><p>set</p><ul><li><p>类似于数组的形式,但是成员都是唯一的,没有重复的值,Set本身是一个构造函数,用来生成Set数据结构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();<br><br>[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>].forEach(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> s.add(x));<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> s) &#123;<br>  <span class="hljs-built_in">console</span>.log(i);<br>&#125;<br><span class="hljs-comment">// 2 3 5 4</span><br></code></pre></td></tr></table></figure></li><li><p>可以进行的遍历操作</p><ul><li><code>Set.prototype.keys()</code>：返回键名的遍历器</li><li><code>Set.prototype.values()</code>：返回键值的遍历器</li><li><code>Set.prototype.entries()</code>：返回键值对的遍历器</li><li><code>Set.prototype.forEach()</code>：使用回调函数遍历每个成员</li></ul></li></ul></li><li><p>map</p><ul><li><p>本质上是键值对的结合(Hash结构),但是传统上只能用字符串当做键,这给其使用方式带来了很大的限制</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> data = &#123;&#125;;<br><span class="hljs-keyword">const</span> element = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;myDiv&#x27;</span>);<br><br>data[element] = <span class="hljs-string">&#x27;metadata&#x27;</span>;<br>data[<span class="hljs-string">&#x27;[object HTMLDivElement]&#x27;</span>] <span class="hljs-comment">// &quot;metadata&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>遍历方法</p><ul><li>Map 结构原生提供三个遍历器生成函数和一个遍历方法</li><li><code>Map.prototype.keys()</code>：返回键名的遍历器</li><li><code>Map.prototype.values()</code>：返回键值的遍历器</li><li><code>Map.prototype.entries()</code>：返回所有成员的遍历器</li><li><code>Map.prototype.forEach()</code>：遍历 Map 的所有成员</li></ul></li></ul></li></ul><h3 id="6、Async函数"><a href="#6、Async函数" class="headerlink" title="6、Async函数"></a>6、Async函数</h3><h3 id="7、Proxy"><a href="#7、Proxy" class="headerlink" title="7、Proxy"></a>7、Proxy</h3><h3 id="8、Promise"><a href="#8、Promise" class="headerlink" title="8、Promise"></a>8、Promise</h3><h3 id="9、Class继承"><a href="#9、Class继承" class="headerlink" title="9、Class继承"></a>9、Class继承</h3><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><h3 id="1、MVVM模式"><a href="#1、MVVM模式" class="headerlink" title="1、MVVM模式"></a>1、MVVM模式</h3><ul><li><p><strong>基本定义</strong></p><ul><li>MVVM是Model-View-ViewModel的缩写,MVVM是一种设计思想,Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象,在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上,ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理</li></ul></li><li><p><strong>图解</strong></p><p> <img src="https://wushuo1031.oss-cn-beijing.aliyuncs.com/img/MVVM%E7%9A%84%E6%A6%82%E5%BF%B5%E5%9B%BE.png"></p></li></ul><h3 id="2、Vue双向绑定的原理"><a href="#2、Vue双向绑定的原理" class="headerlink" title="2、Vue双向绑定的原理"></a>2、Vue双向绑定的原理</h3><ul><li><p><strong>基本定义</strong></p><ul><li>在Vue2版本中,双向绑定的原理,采用的是,<code>数据劫持结合发布者,订阅者模式</code>实现的,通过<code>Object.definePropety()</code>来劫持各个属性的setter,和getter,在数据发生变动的时,发布消息给订阅者,触发相应监听回调,把一个普通的javaScript对象传给Vue实例,作为它的data选项,Vue将遍历所有的属性,利用Object.definePropetype把它们转换为getter/setter,用户看到不到getter/setter,但是在内部使用Vue追踪依赖,在属性被访问和修改时,通知发生变化</li><li>Vue将MVVM作为数据绑定的入口,整合Observer,Compile和Watch三者,通过Observer来监听自己的model数据变化,通过Compile来解析编译模板指令,最用它利用Watcher大气observer和Compile之间的通讯桥梁,达到数据变化,-&gt;视图更新,视图交互变化-&gt;数据Model变更双向绑定的结果</li></ul></li><li><p><strong>代码实现</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt; --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;txt&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">input</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;show&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">    <span class="hljs-keyword">var</span> obj= &#123;&#125;</span><br><span class="javascript">    <span class="hljs-comment">// 1- 监听空对象obj,和input输入框</span></span><br><span class="javascript">    <span class="hljs-built_in">Object</span>.defineProperty(obj,<span class="hljs-string">&#x27;txt&#x27;</span>,&#123;</span><br><span class="javascript">      <span class="hljs-comment">// 2- get属性获取外部obj对象</span></span><br><span class="javascript">      <span class="hljs-attr">get</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">        <span class="hljs-keyword">return</span> obj</span><br><span class="javascript">      &#125;,</span><br><span class="javascript">      <span class="hljs-comment">// 3- set改写,并且把文本,和视图,进行关联</span></span><br><span class="javascript">      <span class="hljs-attr">set</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">newValue</span>)</span>&#123;</span><br><span class="javascript">        <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;txt&#x27;</span>).value= newValue</span><br><span class="javascript">        <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;show&#x27;</span>).innerHTML=newValue</span><br><span class="javascript">      &#125;</span><br><span class="javascript">    &#125;)</span><br><span class="javascript">    <span class="hljs-comment">// 4- 监听keyup事件,实现数据同时显示和更新</span></span><br><span class="javascript">    <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;keyup&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123;</span><br><span class="javascript">      obj.txt=e.target.value</span><br><span class="javascript">    &#125;)</span><br><span class="javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="3、生命周期函数"><a href="#3、生命周期函数" class="headerlink" title="3、生命周期函数"></a>3、生命周期函数</h3><ul><li><p><strong>基本定义</strong></p><ul><li><p>生命周期函数,可以为<code>创建期间</code>和<code>运行期间</code>以及<code>销毁期间</code></p><ul><li>创建期间<ul><li>beforeCreate,created,beforeMount,mounted</li></ul></li><li>运行期间<ul><li>beforeUpdate,updated</li></ul></li><li>销毁期间<ul><li>beforeDestroy,destroyed</li></ul></li></ul><p><img src="https://wushuo1031.oss-cn-beijing.aliyuncs.com/img/%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E6%B5%81%E7%A8%8B.png"></p></li></ul></li><li><p><strong>详细说明</strong></p><ul><li><code>1- 创建期间</code><ul><li>beforeCreate<ul><li>Vue或者组件刚刚实例化,data和methods还没有被创建</li></ul></li><li>created<ul><li>此时data和methods已经被创建,可以使用,但还没有开始编译,如果首屏的ajax请求,可以放到这个钩子中执行</li></ul></li><li>beforeMount<ul><li>created的下一个阶段,此时模板已经被编译,但是还没有挂载到网页中</li></ul></li><li>mounted<ul><li>模板代码已经加载到了网页中,但此时创建期间所有的事情都已经准备好了,网页开始运行</li></ul></li></ul></li><li><code>2- 运行期间</code><ul><li>beforeUpdate<ul><li>在网页运行期间,data中的数据可能会更新,在这个阶段,数据只是在data中进行更新了,但是没有在模板中进行更新,因此网页显示的还是之前的</li></ul></li><li>update<ul><li>数据在data中更新了,此时页面上的数据都是最新的</li></ul></li></ul></li><li><code>3-销毁期间</code><ul><li>beforeDestroy<ul><li>Vue实例或者是组件在销毁之前执行的函数,在这一个函数中Vue或者组件中的所有属性,都是可用的</li></ul></li><li>destroyed<ul><li>Vue实例或者组件被销毁后执行的,此时Vue实例上所有的东西都会解绑,所有的时间都会被移除,所有子元素都会被销毁</li></ul></li></ul></li></ul></li></ul><h3 id="4、指令系列"><a href="#4、指令系列" class="headerlink" title="4、指令系列"></a>4、指令系列</h3><ul><li><p><strong>4-1 常见指令</strong></p><ul><li><p>v-model</p><ul><li>用于表单元素的绑定,箭筒用户输出事件的以及更新数据</li></ul></li><li><p>v-text</p><ul><li>更新元素的extContent,将数据解析为纯文本</li></ul></li><li><p>v-on</p><ul><li>绑定事件</li><li>语法<code>v-on:click=&quot;say&quot; or v-on:click=&quot;say(&#39;参数&#39;, $event)</code></li><li>简写: <code>@click=&#39;say&#39;</code></li><li>使用逗号分隔绑定多个事件<code>&lt;div v-on=&quot;click:onClick, keyup:onKeyup, keydown:onKeydown&quot;&gt;&lt;/div&gt;</code></li></ul></li><li><p>v-for</p><ul><li><p>根据数据多次渲染元素或模板</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vue">遍历数组 item 为当前项，index 为索引<br>&lt;p v-for=&quot;(item, index) in list&quot;&gt;&#123;&#123;item&#125;&#125; -- &#123;&#123;index&#125;&#125;&lt;/p&gt;<br>遍历对象 item 为值，key 为键，index 为索引<br>&lt;p v-for=&quot;(item, key, index) in obj&quot;&gt;&#123;&#123;item&#125;&#125; -- &#123;&#123;key&#125;&#125;&lt;/p&gt;<br>遍历常量 item为从1开始的递增值<br>&lt;p v-for=&quot;item in 10&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/p&gt;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>v-bind</p><ul><li>绑定属性</li><li>语法:<code>v-bind:title=&#39;msg&#39;</code></li><li>简写:<code>:title=&#39;msg&#39;</code></li></ul></li><li><p>v-html</p><ul><li>更新元素的innerHTML,把数据解析为纯文本显示</li></ul></li><li><p>v-if/v-else/v-else-if</p><ul><li>根据表达式值的真假条件,销毁或重建元素v-if,适合条件不大可能的改变的场景,v-if-else和v-else不用脱离v-if单独存在</li></ul></li><li><p>v-show</p><ul><li>根据表达式真假结果,切换元素的diplay css属性,dom元素一直在v-show适合频繁切换</li></ul></li><li><p>v-once</p><ul><li>只渲染元素组件一次,随后重新进行渲染,元素/组件以及其所有子节点,都被视为静态内容跳过,可以优化更新性能</li></ul></li><li><p>v-pre</p><ul><li>主要应用与跳过这个元素和子元素编译过程,可以用来显示原始标签,跳过大量没有指令的节点,加快编译</li></ul></li></ul></li><li><p><strong>4-2 自定义指令</strong></p></li><li><p><strong>4-3 指令面试题</strong></p></li></ul><h3 id="5、组件系列"><a href="#5、组件系列" class="headerlink" title="5、组件系列"></a>5、组件系列</h3><ul><li><strong>5-1 组件的基本定义</strong></li><li><strong>5-2 父子组件传值</strong></li><li><strong>5-3 子父组件传值</strong></li><li><strong>5-4 兄弟组件传值</strong></li><li><strong>5-5 爷孙组件传值</strong></li><li><strong>5-6 组件中的data为什么必须是一个函数?</strong></li><li><strong>5-7 组件中插槽的作用</strong></li><li><strong>5-8 如何实现组件缓存?</strong></li></ul><h3 id="6、Watch和Computed以及Methods的应用以及加载顺序"><a href="#6、Watch和Computed以及Methods的应用以及加载顺序" class="headerlink" title="6、Watch和Computed以及Methods的应用以及加载顺序"></a>6、Watch和Computed以及Methods的应用以及加载顺序</h3><h3 id="7、Vue-Router系列"><a href="#7、Vue-Router系列" class="headerlink" title="7、Vue-Router系列"></a>7、Vue-Router系列</h3><ul><li><strong>7-1 Vue-Router实现的原理</strong></li><li><strong>7-2 如何配置动态路由</strong></li><li><strong>7-3 如何实现动态传参</strong></li><li><strong>7-4 Vue-Router中存在哪些钩子函数</strong></li><li><strong>7-5 路由跳转的方式</strong></li><li><strong>7-6 嵌套路由的实现</strong></li><li><strong>7-7  <code>$route</code>和<code> $router</code>的区别</strong></li><li></li></ul><h3 id="8、Vuex系列"><a href="#8、Vuex系列" class="headerlink" title="8、Vuex系列"></a>8、Vuex系列</h3><ul><li><strong>8-1 你所理解的Vuex</strong></li><li><strong>8-2 介绍一下Vuex中的核心属性</strong></li></ul><h3 id="9、Vue-Cli系列"><a href="#9、Vue-Cli系列" class="headerlink" title="9、Vue-Cli系列"></a>9、Vue-Cli系列</h3><ul><li>9-1 <strong>目录中文件职责</strong></li></ul><h3 id="10、webpack系列"><a href="#10、webpack系列" class="headerlink" title="10、webpack系列"></a>10、webpack系列</h3><ul><li><p><strong>10-1 webpack概述</strong></p></li><li><p><strong>10-2 webpack如何实现热更新</strong></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Git-设置、查看、取消代理</title>
    <link href="/2021/07/13/Git-%E8%AE%BE%E7%BD%AE%E3%80%81%E6%9F%A5%E7%9C%8B%E3%80%81%E5%8F%96%E6%B6%88%E4%BB%A3%E7%90%86/"/>
    <url>/2021/07/13/Git-%E8%AE%BE%E7%BD%AE%E3%80%81%E6%9F%A5%E7%9C%8B%E3%80%81%E5%8F%96%E6%B6%88%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="设置代理："><a href="#设置代理：" class="headerlink" title="设置代理："></a>设置代理：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apl">git config --global http.proxy &#x27;socks5://127.0.0.1:7890&#x27; <br>git config --global https.proxy &#x27;socks5://127.0.0.1:7890&#x27;<br></code></pre></td></tr></table></figure><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h3 id="查看代理："><a href="#查看代理：" class="headerlink" title="查看代理："></a>查看代理：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apl">git config --global --get http.proxy<br>git config --global --get https.proxy<br></code></pre></td></tr></table></figure><h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><h3 id="取消代理："><a href="#取消代理：" class="headerlink" title="取消代理："></a>取消代理：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apl">git config --global --unset http.proxy<br>git config --global --unset https.proxy<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue生命周期-钩子函数</title>
    <link href="/2021/07/13/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2021/07/13/Vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="Vue生命周期总共分为几个阶段？"><a href="#Vue生命周期总共分为几个阶段？" class="headerlink" title="Vue生命周期总共分为几个阶段？"></a>Vue生命周期总共分为几个阶段？</h2><p>Vue实例从创建到销毁的过程，就是生命周期。</p><p>也就是从开始创建，初始化数据，编译模板，挂载Dom渲染，更新渲染，卸载等一系列过程，我们称这是Vue的生命周期。</p><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h3 id="1-beforeCreate"><a href="#1-beforeCreate" class="headerlink" title="1.beforeCreate"></a><strong>1.beforeCreate</strong></h3><p>在实例初始化之后，数据观测和event/watcher事件配置之前被调用。</p><h3 id="2-created"><a href="#2-created" class="headerlink" title="2.created"></a><strong>2.created</strong></h3><p>在实例创建完成后被立即调用。</p><h3 id="3-beforeMount"><a href="#3-beforeMount" class="headerlink" title="3.beforeMount"></a><strong>3.beforeMount</strong></h3><p>在挂载开始之前被调用：相关的render函数首次被调用</p><h3 id="4-mounted"><a href="#4-mounted" class="headerlink" title="4.mounted"></a><strong>4.mounted</strong></h3><p>el被新创建的vm.$el替换，并挂载到实例上去之后调用该钩子。</p><h3 id="5-beforeUpdate"><a href="#5-beforeUpdate" class="headerlink" title="5.beforeUpdate"></a><strong>5.beforeUpdate</strong></h3><p>数据更新时调用，发生在虚拟DOM打补丁之前。</p><h3 id="6-updated"><a href="#6-updated" class="headerlink" title="6.updated"></a><strong>6.updated</strong></h3><p>由于数据更改导致的虚拟OM重新渲染和打补丁，在这之后会调用该钩子。</p><h3 id="7-activated"><a href="#7-activated" class="headerlink" title="7.activated"></a><strong>7.activated</strong></h3><p>keep-alive组件激活时调用。该钩子在服务器端渲染期间不被调用。</p><h3 id="8-deactivated"><a href="#8-deactivated" class="headerlink" title="8.deactivated"></a><strong>8.deactivated</strong></h3><p>keep-alive组件停用时调用，该钩子在服务器端渲染期间不被调用。</p><h3 id="9-beforeDestroy"><a href="#9-beforeDestroy" class="headerlink" title="9.beforeDestroy"></a><strong>9.beforeDestroy</strong></h3><p>实例销毁之前调用。在这一步，实例仍然完全可用。该钩子在服务器端渲染期间不被调用。</p><h3 id="10-destroyed"><a href="#10-destroyed" class="headerlink" title="10.destroyed"></a><strong>10.destroyed</strong></h3><p>Vue实例销毁后调用。调用后，Vue实例指示的所有东西都会解除绑定。</p><h3 id="11-errorCaptured"><a href="#11-errorCaptured" class="headerlink" title="11.errorCaptured"></a><strong>11.errorCaptured</strong></h3><p>当捕获一个来自子孙组件的错误时被调用。</p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>父子组件通信-Props</title>
    <link href="/2021/07/12/%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1-Props/"/>
    <url>/2021/07/12/%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1-Props/</url>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="父子组件通信之Props"><a href="#父子组件通信之Props" class="headerlink" title="父子组件通信之Props"></a>父子组件通信之Props</h3><p><strong>父组件</strong>需要做的：</p><p>1.在父组件中导入子组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> Child <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./组件通信-子组件.vue&#x27;</span><br></code></pre></td></tr></table></figure><p>2.components注册组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">components</span>: &#123;<br>    Child<br>  &#125;,<br></code></pre></td></tr></table></figure><p>3.在结构中加入<Child />标签</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;h1&gt;组建通信&lt;/h1&gt;<br>    &lt;hr /&gt;<br>    &lt;Child /&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><p>4.定义变量data，定义假数据food1</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">data () &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">food1</span>: &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;炸鸡啤酒&#x27;</span>, <span class="hljs-attr">price</span>: <span class="hljs-number">30</span> &#125;,<br>    <span class="hljs-attr">discount</span>: <span class="hljs-number">5</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>5.通过动态属性=》:props=”变量”，开始传值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;Child :food=&quot;food1&quot; :discount=&quot;discount&quot; /&gt;<br></code></pre></td></tr></table></figure><p><strong>子组件</strong>需要做的：</p><p>1.props写在子组件，后边是冒号和数组[]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script&gt;<br>export default &#123;<br>  // 接收：props:[&#x27;父组件传递的动态属性的名字&#x27;]<br>  props: [&#x27;food&#x27;, &#x27;discount&#x27;]<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>2.在标签中写胡子语法，调用数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;food&quot;&gt;<br>    &lt;h1&gt;组件通信-子组件&lt;/h1&gt;<br>    &lt;h1&gt;菜名：&#123;&#123; food.name &#125;&#125;&lt;/h1&gt;<br>    &lt;h3&gt;价格：&#123;&#123; food.price &#125;&#125;&lt;/h3&gt;<br>    &lt;h3&gt;打折：&#123;&#123; discount &#125;&#125;&lt;/h3&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><p><strong>注意点</strong>：</p><p>1.数据需要定义到父组件</p><p>2.可以复制写多个</p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>谈一谈我对Vue的理解</title>
    <link href="/2021/07/12/%E8%B0%88%E4%B8%80%E8%B0%88%E6%88%91%E5%AF%B9Vue%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <url>/2021/07/12/%E8%B0%88%E4%B8%80%E8%B0%88%E6%88%91%E5%AF%B9Vue%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="谈一谈我对Vue的理解"><a href="#谈一谈我对Vue的理解" class="headerlink" title="谈一谈我对Vue的理解"></a>谈一谈我对Vue的理解</h3><p>1.它是一个<strong>渐进式</strong>的JavaScript框架</p><p>2.核心库+插件</p><p>3.动态创建用户界面</p><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><p>1.它是<strong>MVVM</strong> (Model-View-ViewModel) 模式</p><p>2.代码简洁，体积小，提高运行效率</p><p>3.适合PC端和移动端的开发</p><p>4.本身只关注UI，和react比较相似</p><p>5.可以轻松的引入vue插件以及其他第三方库进行开发</p><p>Vue是借鉴了angular的模板，还有数据绑定技术，以及react的组件化和虚拟Dom技术</p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Mac OS 安装依赖Xcode报错的解决方案</title>
    <link href="/2021/07/12/Mac-OS-%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96Xcode%E6%8A%A5%E9%94%99%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2021/07/12/Mac-OS-%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96Xcode%E6%8A%A5%E9%94%99%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>Mac OS装依赖时报错需要安装命令行工具Xcode的解决方案：</p><p>打开Mac-终端-运行以下两行代码即可解除此问题的困扰。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmd">xcode-select --install  # 单独安装CommandLineTools，不需要Xcode<br><br>sudo xcode-select --switch /Library/Developer/CommandLineTools  # 指定路径<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Mac</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue-插槽</title>
    <link href="/2021/07/09/Vue-%E5%87%A0%E7%A7%8D%E6%8F%92%E6%A7%BD%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/07/09/Vue-%E5%87%A0%E7%A7%8D%E6%8F%92%E6%A7%BD%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="默认插槽"><a href="#默认插槽" class="headerlink" title="默认插槽"></a>默认插槽</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>插槽使用<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Pannel</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>人生若只如初见<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Pannel</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>/&gt;</span><br>    <br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">   </span><br><span class="javascript">    <span class="hljs-keyword">import</span> Pannel <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;/路径&#x27;</span></span><br><span class="javascript">    <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">        <span class="hljs-attr">components</span>:&#123;</span><br><span class="javascript">            Pannel,</span><br><span class="javascript">        &#125;,</span><br><span class="javascript">    &#125;</span><br><span class="javascript">&lt;script/&gt;        </span><br></code></pre></td></tr></table></figure><h5 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h5><p>1.子组件标签下传入插槽内容</p><p>2.在子组件中指定一个位置写上<slot></slot>  显示插槽内容</p><p>3.<slot></slot>  用来显示插槽内容</p><p>4.传入子组件插槽内容，可以使用父组件的变量，也可以在父组件控制插槽样式</p><p>5.默认插槽只能写一个</p><h5 id="插槽的默认内容可以在-里提供"><a href="#插槽的默认内容可以在-里提供" class="headerlink" title="插槽的默认内容可以在 里提供"></a>插槽的默认内容可以在<slot></slot> 里提供</h5><h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html">// 写法1<br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot</span>：插槽名字 &gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>/&gt;</span><br>    <br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">   </span><br><span class="javascript">    <span class="hljs-keyword">import</span> Pannel <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;/路径&#x27;</span></span><br><span class="javascript">    <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">        <span class="hljs-attr">components</span>:&#123;</span><br><span class="javascript">            Pannel,</span><br><span class="javascript">        &#125;,</span><br><span class="javascript">    &#125;</span><br><span class="javascript">&lt;script/&gt;        </span><br><span class="javascript"> ========================我是分割线========================</span><br><span class="javascript"> 需要使用的组件中，标签传入name值，显示具名插槽内容</span><br><span class="javascript">    &lt;slot name:<span class="hljs-string">&quot;插槽名字&quot;</span>&gt;&lt;/slot&gt;</span><br><span class="javascript"> </span><br><span class="javascript"> </span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html">// 写法2<br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #插槽名字 &gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>/&gt;</span><br>    <br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">   </span><br><span class="javascript">    <span class="hljs-keyword">import</span> Pannel <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;/路径&#x27;</span></span><br><span class="javascript">    <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">        <span class="hljs-attr">components</span>:&#123;</span><br><span class="javascript">            Pannel,</span><br><span class="javascript">        &#125;,</span><br><span class="javascript">    &#125;</span><br><span class="javascript">&lt;script/&gt;        </span><br><span class="javascript"> ========================我是分割线========================</span><br><span class="javascript"> 需要使用的组件中，标签传入name值，显示具名插槽内容</span><br><span class="javascript">    &lt;slot name:<span class="hljs-string">&quot;插槽名字&quot;</span>&gt;&lt;/slot&gt;</span><br><span class="javascript"> </span><br><span class="javascript"> </span><br></code></pre></td></tr></table></figure><h5 id="具名插槽的两种写法："><a href="#具名插槽的两种写法：" class="headerlink" title="具名插槽的两种写法："></a>具名插槽的两种写法：</h5><p>1.v-slot：插槽名字</p><p>2.#插槽名字</p><h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><p>1.用来传数据</p><p><img src="C:\Users\Administrator\Desktop\2021-07-11_22-26-29.jpg" alt="2021-07-11_22-26-29"></p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
